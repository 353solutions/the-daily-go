git clone git@github.com:tebeka/nlp.git                                                         Sun Apr 28, 12:20 
Cloning into 'nlp'...
warning: You appear to have cloned an empty repository.
╭─miki@saitama  the-daily-go (git:master) 
╰─$ cd nlp                                                                                          Sun Apr 28, 13:22 
╭─miki@saitama  nlp 
╰─$ cp ../data/nlp.go .                                                                             Sun Apr 28, 13:22 
╭─miki@saitama  nlp 
╰─$ ls                                                                                              Sun Apr 28, 13:22 
nlp.go
╭─miki@saitama  nlp 
╰─$ go env GOPATH                                                                                   Sun Apr 28, 13:23 
/home/miki/go
╭─miki@saitama  nlp 
╰─$ go version                                                                                      Sun Apr 28, 13:25 
go version go1.12.4 linux/amd64
╭─miki@saitama  nlp 
╰─$ git add nlp.go                                                                                  Sun Apr 28, 13:27 
╭─miki@saitama  nlp 
╰─$ git commit -m 'initial commit'                                                                  Sun Apr 28, 13:38 
[master (root-commit) 39ec009] initial commit
 1 file changed, 22 insertions(+)
 create mode 100644 nlp.go
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 13:38 Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 4 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 456 bytes | 456.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:tebeka/nlp.git
 * [new branch]      master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ go test                                                                                         Sun Apr 28, 13:38 
PASS
ok  	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 13:53 
=== RUN   TestTokenize
--- PASS: TestTokenize (0.00s)
PASS
ok  	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 13:53 
=== RUN   TestTokenize
--- FAIL: TestTokenize (0.00s)
    nlp_test.go:15: []string{"who", "s", "on", "first?"} != []string{"who", "s", "on", "first"}
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s╭─miki@saitama  nlp (git:master) 
╰─$ go test -V                                                                                   Sun Apr 28, 13:55 1 ↵
flag provided but not defined: -V
Usage of /tmp/go-build830051107/b001/nlp.test:
  -test.bench regexp
    	run only benchmarks matching regexp
  -test.benchmem
    	print memory allocations for benchmarks
  -test.benchtime d
    	run each benchmark for duration d (default 1s)
  -test.blockprofile file
    	write a goroutine blocking profile to file
  -test.blockprofilerate rate
    	set blocking profile rate (see runtime.SetBlockProfileRate) (default 1)
  -test.count n
    	run tests and benchmarks n times (default 1)
  -test.coverprofile file
    	write a coverage profile to file
  -test.cpu list
    	comma-separated list of cpu counts to run each test with
  -test.cpuprofile file
    	write a cpu profile to file
  -test.failfast
    	do not start new tests after the first test failure
  -test.list regexp
    	list tests, examples, and benchmarks matching regexp then exit
  -test.memprofile file
    	write an allocation profile to file
  -test.memprofilerate rate
    	set memory allocation profiling rate (see runtime.MemProfileRate)
  -test.mutexprofile string
    	write a mutex contention profile to the named file after execution
  -test.mutexprofilefraction int
    	if >= 0, calls runtime.SetMutexProfileFraction() (default 1)
  -test.outputdir dir
    	write profiles to dir
  -test.parallel n
    	run at most n tests in parallel (default 4)
  -test.run regexp
    	run only tests and examples matching regexp
  -test.short
    	run smaller test suite to save time
  -test.testlogfile file
    	write test action log to file (for use only by cmd/go)
  -test.timeout d
    	panic test binary after duration d (default 0, timeout disabled)
  -test.trace file
    	write an execution trace to file
  -test.v
    	verbose: print additional output
exit status 2
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 13:55 1 ↵
=== RUN   TestTokenize
--- FAIL: TestTokenize (0.00s)
    nlp_test.go:21: empty: []string{} != []string{"who", "s", "on", "first"}
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 13:55 1 ↵
=== RUN   TestTokenize
--- FAIL: TestTokenize (0.00s)
    nlp_test.go:22: empty: []string{} != []string(nil)
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 13:56 1 ↵
=== RUN   TestTokenize
--- PASS: TestTokenize (0.00s)
PASS
ok  	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 13:59 
=== RUN   TestTokenize
--- FAIL: TestTokenize (0.00s)
    nlp_test.go:21: []string{} != []string(nil)
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 14:06 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/#00
--- FAIL: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- FAIL: TestTokenize/#00 (0.00s)
        nlp_test.go:22: []string{} != []string(nil)
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 14:06 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- FAIL: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- FAIL: TestTokenize/<empty> (0.00s)
        nlp_test.go:26: []string{} != []string(nil)
FAIL
exit status 1
FAIL	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$go test -v                                                                                   Sun Apr 28, 14:06 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
PASS
ok  	_/home/miki/Teaching/the-daily-go/nlp	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ git add nlp_test.go                                                                             Sun Apr 28, 14:08 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'added some tests'                                                                Sun Apr 28, 14:14 
[master ae525f8] added some tests
 1 file changed, 30 insertions(+)
 create mode 100644 nlp_test.go
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                            Sun Apr 28, 14:14 
.
├── nlp.go
└── nlp_test.go

0 directories, 2 files
╭─miki@saitama  nlp (git:master) 
╰─$ go mod init github.com/tebeka/nlp                                                               Sun Apr 28, 14:14 go: creating new go.mod: module github.com/tebeka/nlp
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                            Sun Apr 28, 14:16 
.
├── go.mod
├── nlp.go
└── nlp_test.go

0 directories, 3 files
╭─miki@saitama  nlp (git:master) 
╰─$ export GO111MODULE=on                                                                           Sun Apr 28, 14:16 
╭─miki@saitama  nlp (git:master) 
╰─$ # do the above if your inside $(go env GOPATH)/src                                              Sun Apr 28, 14:17 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'adding go.mod' go.mod                                                            Sun Apr 28, 14:18 
error: pathspec 'go.mod' did not match any file(s) known to git
╭─miki@saitama  nlp (git:master) 
╰─$ git add go.mod                                                                               Sun Apr 28, 14:19 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'adding go.mod' go.mod                                                            Sun Apr 28, 14:19 
[master 858e1c7] adding go.mod
 1 file changed, 3 insertions(+)
 create mode 100644 go.mod
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 14:19 Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 4 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 899 bytes | 899.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:tebeka/nlp.git
   39ec009..858e1c7  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 14:19 
# github.com/tebeka/nlp [github.com/tebeka/nlp.test]
./nlp_test.go:4:2: imported and not used: "reflect"
FAIL	github.com/tebeka/nlp [build failed]
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 14:24 2 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go mod tidy                                                                                     Sun Apr 28, 14:24 ╭─miki@saitama  nlp (git:master) 
╰─$ go get github.com/stretchr                                                                      Sun Apr 28, 14:25 
go get github.com/stretchr: invalid github.com/ import path "github.com/stretchr"
╭─miki@saitama  nlp (git:master) 
╰─$ go get github.com/stretchr/testify                                                           Sun Apr 28, 14:25 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ git add go.sum go.mod nlp_test.go                                                               Sun Apr 28, 14:25 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'using testify for testing'                                                       Sun Apr 28, 14:30 
[master 8544121] using testify for testing
 3 files changed, 20 insertions(+), 4 deletions(-)
 create mode 100644 go.sum
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                            Sun Apr 28, 14:31 
.
├── go.mod
├── go.sum
├── nlp.go
└── nlp_test.go

0 directories, 4 files
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 14:31 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ go mod vendor                                                                                   Sun Apr 28, 14:31 
╭─miki@saitama  nlp (git:master) 
╰─$ ls vendor                                                                                       Sun Apr 28, 14:32 
github.com  modules.txt
╭─miki@saitama  nlp (git:master) 
╰─$ go test -mod=vendor -v                                                                          Sun Apr 28, 14:33 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ # You can also set: export GOFLAGS="-mod=vendor"                                                Sun Apr 28, 14:34 
╭─miki@saitama  nlp (git:master) 
╰─$ git tag v0.1.0                                                                                  Sun Apr 28, 14:34 
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 14:42 
Enumerating objects: 8, done.
Counting objects: 100% (8/8), done.
Delta compression using up to 4 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1017 bytes | 1017.00 KiB/s, done.
Total 5 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:tebeka/nlp.git
   858e1c7..8544121  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ git push --tags                                                                                 Sun Apr 28, 14:42 
Total 0 (delta 0), reused 0 (delta 0)
To github.com:tebeka/nlp.git
 * [new tag]         v0.1.0 -> v0.1.0
╭─miki@saitama  nlp (git:master) 
╰─$ echo Back 3pm                                                                                   Sun Apr 28, 14:42 
Back 3pm
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 14:44 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:06 === RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
    nlp_test.go:52: 0
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:08 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
    nlp_test.go:53: 100
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$go test -v                                                                                      Sun Apr 28, 15:08 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
    nlp_test.go:42: 򔌆𵜦𲧻񘨠򝃣񕗭񈸊􎞪􁩟𥑄𗀚񥾜񽄂󲧈񅁄򠕇𚭣𱇀􏋱󌍷㥻񜩄󼶎򌀢𷄫ꉑ򏉃򴩮󠦳򵜎򇕳􈂛󨙘񱉾򖆔񮝣񻛒󀪁񩺨񢰵𪿥󥐗򏰳􉝝󷠘񭟢󥩩򍐳񬽹
    nlp_test.go:42: 񅇈򄳃୳򝁄󟿮񵬥𕣏񕨰󑛘񇈛򘹅򋢬􇯾𹺧񡗖񃣃ࣟ񵱖񵓟񇹓𚙹򁜙򳾏񘂩􂣷񩓂򋦳򡥢򲺢󳭵񔔛򐾹񋤒
    nlp_test.go:42: 󕂋񛜵
    nlp_test.go:42: 󧚲󇚡񊲒󵿫亷𻐄󹚬
    nlp_test.go:42: 󽟼󪞒
    nlp_test.go:42: 𬗥𙴋󋩌򃇳񆕙󪓕༴󮼽􈢪
    nlp_test.go:42: 긻򋓰𱇫򹧯󁊙󭲍󈱜򜎽򳺄𩞮󽀶𶱋􎔩񈆖񓼑􈩐􋿴򌛤􄪹󪒛𱼍񴁕󥭏򾺊򟭞󼨣򔻗򮒓𽌹򉧯񁭖�䉱򶴚󹞴󂘂𸱜򢖟𭵕򺩎񸋶󳫅񇕳􀕜𝂞
    nlp_test.go:42: 𗸸󇆼🠌򍒌󄭙𮾀⛷񠅑쩑񦣜񎷅񂋄夤󓈭򺧵򫥖򬓫󊽱򷮎򚼂󰑕񖖰𤁺񞠫񟕄𤱼ෝ󧝥򬆇񮴧񒥽񱨭񊲚򄋜⯝𓢊𕎉񟧖򀤕򬐖񢒔
    nlp_test.go:42: 
    nlp_test.go:42: ꊻ𴬽󹍨򯆅񋱸򺤭𘳾񗺊􏽅ힴ񆪬󶫖򹢽򐓸󵜋򚟂
    nlp_test.go:42: 𭪤󄙟𨭣󑭭󙘸𙺏񗳹񋥴񠡏󽐖򼄿𯃎󖔰򠗈𼁛烴􀂅񘹂
    nlp_test.go:42: 𱨺󬂅򉸉񝨨䐊𥃳󞎗򎐩󆹫򼮛򫊤񆷫򌡹􄩫憎􀏙񿭌񵐭栠򘓆񹧭𬱓􅘹䦶򁲾򘦧󛍵񚴍𵻿􅣂񟱊󦤽񲰍񚡯𿹪𹺓򆐁򋧼󘃔񠣿񵥎􎃜𰤧򴲡𦋂
    nlp_test.go:42: 𔁴𢾤񳻟􏙻쯂򂳄񚏼򛁋𑗆򒄔񙑕󍉎󹙧󐚤񭢋𶋃򛵨񍥹򵜤񢼗펗𾅸󶰬𩆴󀍚񜕴򧝉󘽨󞝠𳁑􁾸񓟆񞇪񁩒񽐚񑞰𘊾󆃳򾢽𴲄񊧤𦡦𰹘𺠄򶠹𑝰򤟲󱉚
    nlp_test.go:42: 󪽗𥔖򺑴򑼙񄢃𮒍򨂗𑘁򰻕򂈏񒗊􁲺𐚵􂹋􈓫𪖗𝪁􏚌𭴕𒣳򓈥󰰍𶓤𸋽񷥐󾲙🙭𴼭򳲷𻘜򀲑񪢥򕉱𩇅󰵲􍓓񁌶񚛍򣖪򒪖𫱢󭔐񅨼􆟰򕢧񅟼򯠔𓆭
    nlp_test.go:42: 󫱯􁶜
    nlp_test.go:42: 󘺌𷹶򒽴󅒬򶌳
    nlp_test.go:42: 欈󿹓򯜠𘺠񥔝󹎥񮾕༸󋺴񘾟𝂆񽊅򑎆𲍌򮿿󅃾󶈫􉳒𠕹򗏶𝘥񸲋􏏨籅򨉾򽨷򳕍󧝆򰵷񯭱󱵝󌝩񟱌񔖩🀐򩥏򃎰
    nlp_test.go:42: 𘩐򭧇󖘞𘛏񺤐򀑥񮑁񎻧󰫍􈰆󵜵𻸘񹼲򨨅򄧻񔆷񺺐򆯑𹼩򀌈󌖏󎿀񝼩
    nlp_test.go:42: 󅋬򩟤򚝖򬎻򾖙
    nlp_test.go:42: 򛿕𼉥򚶮򀗹񬊗軯󦵊󳧹򪁛󃽿򹞣񀳁𸔨𕖯󳻳򒂡
    nlp_test.go:42: 򦘙򏷲𞿳
    nlp_test.go:42: 󀴓𥔴򞻛񌊁裡􂷂󢅨򅿧󔕄򦈳𯄰񹷖􅞘񹠚󞴽뗒󭯟񊱍􌟲򛥀󧎎𘴢񦾫񅈹鱝񀚹򲅪斆󳟉񢓛񰦴񨬒򈷻𬙬񀲝򫱼񖶳𥖎󢢊󜄂􃑷䮭􆿻⦅򈀶򧶐
    nlp_test.go:42: 󎡄󽿰󵿸򙇰򤰻󟅒
    nlp_test.go:42: 񗗲𲱩򆩅𖏤񇯿𓽫󔗕𵓖򃪥􌪬󏮜󻕹
    nlp_test.go:42: 􃛨𲸅󷔥𪤸󛷵򷭢𗫂򦍅򀬜ⲽ󸘱񃪆򇌽𛕺􄃏񺂣󆠩񂯕򉒪􁔹󠰳즻򕠖󫎓󱗷򜓫񝯖񬲇򾑱𘧌󪂀𹰨󿎉򦻪ꓷ󍴴󪣥󅝼񁞮𢣻󤼖􃋅񦢑
    nlp_test.go:42: 󅧱󾀎𜟎򺾝𷪡񓊭򤝲쫇􋐈񛋼񾙌񥁩�􊦡즖񇦷񥫊񠜓񎯱򫰖󆖟󣣐󚰯񞼦񇊩񙒿�񤄤𝤰󀸪򃨞񼞏򏽗󗆯𣝮񺿩󦼝𷗯𳳉􂘕󻤩򡔵𯳛񲝇
    nlp_test.go:42: 񩍡𹳡􉭸򖒂򄩇򸱊𲴦䠩𘰬鰿񘯣񵴷󟼒󸓝󰁙򄰬𒙚
    nlp_test.go:42: 󓒉񟕿򫂕󕬸򤷯񽫉􊙵𪿷󳜿𓏅𿚼𕉆򭿨
    nlp_test.go:42: 𪋸𥨩򙵽󆿙󐐖񖼭󞡛񄓃𲰫򔓏𪗞򭣸򓯅𑔌򺯿񵛎󪷻񨢫򓗸򹑙񠣛򗃃𫱢𱴱򻒃𷣔򑟶򻎂򶹚񵼼񠿲𽢻򥑸򝆀񘙅򿳋񌚪񨄎󚑰򼜎󺵅􊟘󄙔
    nlp_test.go:42: 򂍲񔐉򩤹󣆱󌋚𕷘򑨍󅐙򱓴񵾀򀉛򻐰鋴󐼢󌻢
    nlp_test.go:42: 򙏳󵇥󂿶񓧤􏧮򓟿󻹧󸥼񽈡󁇦򕆀򍤪鍉󧺧󠠟𤽌𙴀ᰀ𾱓񐼗񗧨򝜱򢫜󉢜򪓉񗎯
    nlp_test.go:42: 񞂚򼾶򭠒󉳗󩌦򋌱怉󋩇󹙈헑򰉏񭷃苗򢜹񹯎􎻩񫌋󳷟񿗿򵵰򇓾򎷺򃅠񜭡𡝕򏲵𝑍𘕄􃨔񩉒􂒕󤖐񹴠𥭱󉪂񒻠𣃢󳅍񉥺񴎲񂕊𜁭򼲼
    nlp_test.go:42: ㍻񅧐򉍾󀣋𱗧𻎦𖾏
    nlp_test.go:42: 򻖃􏝌󶶄񟯤󾝻񎇕񋆩􌧲񌯊𲀦򻦲𜠠󃋽񌒪𴥳𘲻񔺀񋦛
    nlp_test.go:42: 񂚋񋭮򁴺򛝿񂔫񻷉󱓧򥩜񥅰򈥾𙩳򬸍񗖡񼊺
    nlp_test.go:42: 􃬠𓀳񸕲󧧠𹼩󂡻󇮅
    nlp_test.go:42: 
    nlp_test.go:42: 𥩯񓪆򵞜򄎙񧅠򺇩󰣑𒳖񔩤񨛴󬤩󨦄𯏟𚱣򑚁𯇍𨿘񛓎󯍠񧟕򰮀󐐸񍬏𻦨򀘄󔪊󌁹񇺻𽘲󱓆򨁡򯓰𑕦󄙽򃩰󿅊􄩡񥆩󬶫򰔍󘀄𜾭󍧬񵽜󖮌𚾣󨝶
    nlp_test.go:42: 󔐾𓧥򠓏񳯧󟜙
    nlp_test.go:42: 𭊟񽙔򗛥󭷻񶛹󷛑񠀟𮺯򴘛净񉳩󝞑񦰅𼲐񊮝󉓽𮃽𩼰󜳭񅱖𪤙󧭁􁗀򔈄󵩹󼎟󕱈򸋎򰺯򻿟򇼳􄘠𘗄􀆞񂵷񔒴򼈑󩬥󈈋󞣪񑊑񷙻󐋣򖪍򤅟򤮄򹎜򠝅򌂱
    nlp_test.go:42: 󘚀񴵜謑񻆞𖠟
    nlp_test.go:42: 昸󏏁𒸬𠧌񊍩񬠁򴴧񦈗𧫭󠟡󶉤񦪀􅩣򚙔釴򉰑񟓍񪐝񵥌򙰟𰞃񰡃񉻼𝦞𡮇󦸯󑰩򾸢򾁸󫐄󚄒󽊐򳳡򪲥𦖏
    nlp_test.go:42: ﷼󀵷󫹻񌘞񮆉񍸅򡠅񔤜󋢤񜀘軮󥑺􎖨񢶫𴆀󂊢󿕵󡭺􀶘𫮼𷌥񺢋𾀼񘭜񯓟󊧢񆀫𐡝󊪹󆼡𩄎
    nlp_test.go:42: 찃񱘴񘕡
    nlp_test.go:42: 􎛡󅒔񓴑梊񓑨󈤟񗽍􇾴򀏳𸌯񟈰񣼒󙔕򻐗򟔜򟝼򃁯󗌗񇉫򨌧𹑗쿎󤫓󂧖𶧵󓊴郶򒵾󀋈󥚷ᑻ󧮭𚛇򞰫󤜨񤈥򮟢𤽝򓨇𵍂𜱏񹇈򲎚􁖌
    nlp_test.go:42: 񐥕􊺂򾂶㈲𕗠󶏰󾑐ዾ񾝢񰛝녇蛅󁊇򮝶󾦉򸭞𐧰󚮦󇙤󎱗񁄴򷼼򐱁󖦸񟤚񕱆򾖖򆾃󈡶򾝿󌄜󍮸򢽉󭓇􉜌
    nlp_test.go:42: 󑸣񕿽򃧧󡂄󠁔󥸍񲶒󣁻󾊾񜹘􈋹򟐁𘒍􈞾񞅜򼭮񨤉򺩧񾎻򦞱󚤛𾇶󈗏𯄗񠟕岤򀗋򎄷񥶦
    nlp_test.go:42: 񧿹󤎤𒃦󰛷񳤣󑔷򋰗𳐶򒲕񔐩󚹦抐򻜖􏳫𫗔氍꘡󥳅񟋡莹򋌃𓭤񘟟񪀭󀒨󡟍򚯄𝸞
    nlp_test.go:42: 񣺒򬺋􉏾𪌦㇧󉞊
    nlp_test.go:42: 񳯦뫦􎤾񀿌铀𞈺񋔆򇊗𧣱򛯻󽲷󬴑�𡏄򐟁򜨤􋙇򘆠񳮉򬕟𻔞𸴨
    nlp_test.go:42: 񑾉𢽐񻨥𪘭񜠖
    nlp_test.go:42: 𒽦􌬵񐶟򛹬𑳜򹪲淽񺔁򇂪󊟅򚼔񥈭󫐈󾁃
    nlp_test.go:42: 􄡪򩧢񬅇󋤘󱓬苢󁯇򹠅򄣊񜷎񶈩񆫶򒡚𵲔􍴶
    nlp_test.go:42: 󘥟򲧐𹭄򟞿񠗺򋻧򎤕󁸿𬆱񣳷􂣁񿖌󲠃𕴳񀝖𲏚
    nlp_test.go:42: 򦞴󹒊󳙸􁬥헹򆒚򟱌᣺𡞬򥌜󐷿􀾵򢨺񯲭􁃁񩺀򘥐񸃽󇈮
    nlp_test.go:42: 􂃷𜐰񟸜𣕐󂋥򕧗𷻉񜃹򜹮񥝀򁬞󦞻򬧳󔼀𖅡񛧎򘆲𛊾񌥨򻴸󼟫󱰝񠧢򛃭𷟾𘒏󎒝󣱩𻾝񚤎󰺑󞝈ㄵ򄡂󀁛󒐦𬬂򢣭񙨉𘕧򱚸𭞊󳤦򸤯񖈢򓗳񝁄
    nlp_test.go:42: 񮃪𭴻󊋍򲒫񡚞񋸢󚀙󏓚󳩆񮪬񥻚ꐞ񮂬򞘛󧞡
    nlp_test.go:42: 様𑧸󄑧󊓂
    nlp_test.go:42: 򂔒򊉃󑶬􎋔񪙕􌪃񬖃
    nlp_test.go:42: 񬿉􃎛򐼭󊮚򘒤󇪍񒓸󥿗󭪶󋠁𧻚᛿򛴡񐐩򃂭𧬚񎜅񘆍󾨅󞲐񱣍𿂎𬳹󲊎𛻐𭵿󱜅󄤯𡵄󟺡󕫦𓠏󑍑󲳂랥񄌓򸬠󘊤񇌤񌶝
    nlp_test.go:42: 𖣜񋇛𱵝𧌇񛆆𗍐򠞚𚛌񆍎򪣱󸃹񍔏􃐾󁇇󯧢ᘵ񁁋淔򺅍𑌫񬏸󎗷𳾉ࡢ򮅅򾫍𽞣񈁚󤳔𾙉񰱊􍧝񒜺󰂉𘦨
    nlp_test.go:42: 󑸡񈵃򗯉򪹐򊃳򖋼󕤇񃸢󊶍񕼆򶆷𓕃򷄊񢞈򻐳𙅆󧩗𝹈򕪒򱕶𢒅򭬏󎍢󆓅񨱟󑔒񃲩𴛍񺺩򎩑񅷥󞖉󿧨󡽩􉌱󬥤󴰡𪨨𢙼􅈊󛜬񤓷
    nlp_test.go:42: 󯛬򹝞񃍊𻹞񸄽򘆾񱜏񗉪𸐨蓔󙒞񲨛񑬔򶋮􋋟򺾠𾈶򊁟񙲐򿸪󚷰󦸓𼃨𶈈򩎬𱡵𧣲𣊅򚌾񎅹񈴊
    nlp_test.go:42: 曺𩽖󡟬󗃺򪡎󑣐󟢽F🪷򆺒𯺒𪘏𲼱𶡹񵺛򰴂󘵀𫪕򬰙󟈰񮡔񜌋񉽟񛲃򓘜𺨳󳃧𑁶񫼔􋡥󗕂񉋳󅩄
    nlp_test.go:42: 󸝡棔򈉱񠫚򬯷󬸄𤌏𐗎𖄠󐧢󬼹񆴑󳠴񈵳򩎰󜩍咖򬸬񡁫򬚳򮸽򐿈񍊋୹󱩥򡪓򡅮򋖢󎭤򌨰𫾈𼩝𿸕
    nlp_test.go:42: 򿟵𹝇𒊗󏯪󺵞󧤽򌵇󣴐򙳱𷵴󆜢񂣪𹫆󡳜󏁖󎮉𹿐󹷒򄢾񁙭
    nlp_test.go:42: 󲼹󚯳󡨝񤽳󘨻󿚛񛰞􊘊򫍖򯣞񌒮𣕘򫰣𲉂󙜸𳞺󘟵󫹓򏠚𗈔񭺼񜠝󱌀󛘶𲎿𩺑𑇴󶮈򪖿𜔠󜒨򽵾񆟒󛏷񒽟󾈧󺹿񰁖񩼳𬸷
    nlp_test.go:42: 򄍶鱼墾񆘷𮎤򡭭򐌥󆇋󖱅󱳀󶰵򋼪󅨚񤱟󩆗򀰣
    nlp_test.go:42: 򤶳򧆹쵒𫎯􊞩񯔉񟫱񶕣񞶎귓󏲓󟬛󔃺󻾔󋻏򉆃񁧎󹶱񫋲񴈸𸜨󪬤򭭱򜲵񪅟񬘈񣕣񐟨󪦽ሙ᱘񨈅򓷕򁧘򴧨򡱒᭠𜢨򞨤񈣫񐜠
    nlp_test.go:42: 񜘸󞹌𥶵񣄫򺰱󠀍򾤥⽗􀲀򘂄󱂂񙊇󫽃򃺟󊶥򃘅䚆񲋔񐥴񊁔򿓈𤎹뇿𙃵󳚽򈳳
    nlp_test.go:42: 񱵓򃤞𱃵򙕁󖞖𞍬򻠜𝒁񌭛񳙨񜐦񲇌򶜌𙳉񐌦򟫣𦫺𢸘񢡱񑞔󕉙񐱊
    nlp_test.go:42: 򑮧󄴌𖐉򫍄𐈃􉪛󸄮󥀳𘞢󄁀򻆃󛦭󆹅򜇳򼕾򶧷򺲍񩠋Ӧ񤊱卪𪃓񞩅󇏬񉵬􁮌򛢣󧶚񴋌򤝻󫠐񽻽񃺾𢷾𣍕􋬓񉭚
    nlp_test.go:42: 썶󂴝묭𞏶𷛗𹍓񈡉󽲰󅞩񬦫󘗳񤤼𙝎򉤫񜜷􏒑񜍆󦦃񗋌򛀵򮖼􎺿񌖕𔒶񻑩򘵄񬉄𱑫𖲆񄽹򈅦
    nlp_test.go:42: 󜺈󽦗󸓩򵡤󊂀򜞖𺻤񣿤ᓗ
    nlp_test.go:42: 򭾡􄀱𺌋𻶜򡚘񺋆򈁳󩿎󱴭񕕭󂝀ꫤ𖍟񭞵􁟌򄻔򎬃󡒔򺀍򔂑󥯮󡨾󇢵󘼆󲄊󋍊
    nlp_test.go:42: 迶򸻹𷨈򌖴𦭹򨼦񘘝񺈝䂸𼋉񥌿򢳓󝑋񶏤󎓞𮅜􂏿󜓭񲩂񹬉邴񟻊񭻑񪊹򜐙򈿗񔙸򛙕󢛋򐅖󋠱󏑢
    nlp_test.go:42: 􏎣񁬀𜑤𕗿򸤖񾅰𰵸𣝖񿻆𭑠򻪊𯾙󷝦󣻔񈢶򓄻򇄱򾿃񏚿񋡣􋅃򡜱󄬿򾅒󗡙񅰚󟩄򦵁񼍥𔔜䭩󵪟裦򉔤񕆭󝾂挘
    nlp_test.go:42: 󣷂񼉖񪡏򪀦󩘎񄇖󨄍򝉅򙘷𘨏󀐬񖯵򙲭򞿷𧎺󚊹򡘢򓖢🋴򈏎񂪔𳬿𿄁󼔜񡿙󖧰򃽒󮬚󭞦𒖖񘔌󫃧񽽔󔞈񗞙񞈚𗗾򢏹𻽴𤗆
    nlp_test.go:42: 򚷤𦛸񢬅򗚳􆴧𧒴󾹌􋁚󒤳󦐿󐻔󈚆􆌂򿴓󊭔𚿒򰮘𜢮򱱾󓉓劥󫘑򏍪󹺠򞊇
    nlp_test.go:42: 񅯹򔒘𶆈𚡴󋐻󷲑󦋞󪗈򴓁񶉰񏇞񳹢𾁨󲿯򂇠󐷙󟢏񪒐􇑖񴀉𖉘𓨹򰧰񆄈
    nlp_test.go:42: 񛄐𻳵󖀷򂠂񩤼󃨅􊋾򖉵㍺񕽅񻤓􏛐鿷򧌈鑋񾔲򖪁񂺮񙓙󒌈򬿵재񄞜񘎲񍛩򎻭𵦯񖘲򭔚𚒄𧔸򒤜񏻾񮭫𻽄񺘦򙇔󟗬򄷊򮁳񠠭񉜈񔄴ﮰ񺃟􋵫񻴯󹹶󧡔
    nlp_test.go:42: 𙾛
    nlp_test.go:42: 󸮌𮚢􈟃𸲫󋖥􁕬򽚲𓁁񉹦𠌅򨚭󚏏󁴜򯖎󬭂􎘻񌦱󹡵񡲻劲
    nlp_test.go:42: 󁦈򗫹뮖
    nlp_test.go:42: 𶇅򎟾𿜎񸀡񷒪򳹝僼𒮱񌿹򰓎𡐠롅阠񸟳󌋸񘱞󞣢񍟢񷜿򮸫񠋱𗸈񔡝񕥣򵒭󡪅񖯥󏘑𑾞󵥚𛸠򿃨򞘍󨜊񕋵񒘏󅎹𧡏񘋪󟰻򆈨
    nlp_test.go:42: 𦋰򇛸󘵄󟕔򚁱񭓞򣨱򻴶𯕏􅜍񈘭񴞦񡶣񬝬𥯐𱑽𯇞󲲚𕫯򌈔𛰖󮮜󲯘򊡴󅠕󲁌򽶭򚠕ᙜ󏸉򞕼򾐩􈴕𰬓󙇌񵥩񙊝󅔏򻉭󺺿􇬹򺟒
    nlp_test.go:42: 񴌵𻻅ྡ󗜪򟘰򑪡񓲣𐫜󨡹񿞒񀙚񄝠󋸎򎱳📘󕍯񄴥򍘌񦀩󯄍񚼍𑩙򦦉
    nlp_test.go:42: 񮱤񭸤񠳄🍁𢂌㬲𺍎񆔒򕿡𴏳򮨾񑔶񑬈󵫇􌌵𚽕񻴸񹇭򴄦󠝰
    nlp_test.go:42: 򸷞󄇍򂎞󼋜񤫞󮗁񳲹򩼼񄯶󨯌獭󶶞𳟌򅱤忈󌨸𳵣
    nlp_test.go:42: 𛂤􈫈򀆒򈟣򄁝󢊻񈦬򼓎􆇒򬠖ᰈ򬌼󢋈񳦮􊚎󃛯󘯋󿰽򥶝񶑬󉘷񔑪򵄃󳾊򬛬󸹺󖈎򷤦򵷻򮛃
    nlp_test.go:42: 򱦸񇯚򵠱𧸛񎋢󶐙􉔁𩰮考򔄌񍧢􂃙񶾜􁇘𠫇򒺯󜗠򣻺񙸍񳩓򍮞󔻑񻛘
    nlp_test.go:42: 򡶞󌀳产󥺨񶅕𯈀󡙝󀼬򒜵縀񄫘퓯򤠱𥠠򱘹򨺥ⶍ񯿍
    nlp_test.go:42: 𡐙􋿐񷺬񌇩񾱀򒼥󆦼򓜛񼢓񘋡񶰿﷈񓧄񺟾󭙵󦍆糄򷖈򙆰𶧓󊜶򢕝򌅨�򂃏󾉀笡񟞥񝰷񓷞􎹇񗬓򚪰󳺹򩫍򏃜󘄦󊅌񬖿􈃘𴫡
    nlp_test.go:42: 󹳕𸭫𠡩򍌷񎤿𗘂󮃵񜐵򸴄𘞒񸔈󛝜򹇈򮩈󰹮򃱞
    nlp_test.go:42: 𒾭𖥡񠰴񜌸񠩵𴑰󌁘༚鶶󒆁񛸅񡥣𨂱󡕑񨇋񜸫󴡔􆳩󊭪𮆥髑񴢒񺠱𠕸򹰲
    nlp_test.go:42: 򾕝􃟿󖿴򫟺󜐤򇬈󁌦򥔮󗰅򛍢𝶡󨥈򫿯𗽻񠦺򋰍򍖧󼤌񬟵𹗶򒷠򙇠񔊼򬴛򲊅𶥲󿑲󰁳
    nlp_test.go:42: 򨂏򹡈򛯑󹭊򫜧񻤢񇹾񸕌򠅘󍫻񢫌񓔪􋕁󆩓񿜤𺏤𹵱󌍔򱭇𾡥򄖰񅵵񲿳񉜡򹠶񚥼񺦏󜔒𹉎򏫺􋵆񧇓񜻿𔐭񸜉𣖐򀺱𙣝𠋠򲳮񕓳𙏬𿮵蘃񿇰󡚧󧤮񩵹񿈌
    nlp_test.go:42: 񭷬񅿡󏓩󪙙󏩈򁄋񐼅򌮲򴼪򤇀򙭲𭂲介󉜥􈤀򽠅񙏏󧤤􂉤𙜽򏷡󚲘񽸒򍒬󫖀􍴖򥵢򂺋񀵁򀦄󝧣󸢢𔎩󲣽򽽜񏯘🔦􀏃󶟗󌶍
    nlp_test.go:42: 􎪹𪡔򋄬􁓩🫄񹳇򀠪洬󄚚񚒍
    nlp_test.go:42: 񏩼񽂇𬕸񂍊󼸺󅃼򩊨򜙼󀹌󄙫񅋷񙠁󂡓󛅼󔬥򰇩
PASS
ok  	github.com/tebeka/nlp	0.003s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:09 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:12 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- FAIL: ExampleTokenize (0.00s)
got:
[what s up doc]
want:
[what s up docx]
FAIL
exit status 1
FAIL	github.com/tebeka/nlp	0.003s╭─miki@saitama  nlp (git:master) 
╰─$ git add example_test.go                                                                      Sun Apr 28, 15:13 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ git status                                                                                      Sun Apr 28, 15:14 
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   example_test.go

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   nlp_test.go

╭─miki@saitama  nlp (git:master) 
╰─$ git add nlp_test.go                                                                             Sun Apr 28, 15:14 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'quick & example tests'                                                           Sun Apr 28, 15:14 
[master fe1ffc4] quick & example tests
 2 files changed, 31 insertions(+)
 create mode 100644 example_test.go╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 15:14 
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 4 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 712 bytes | 712.00 KiB/s, done.
Total 4 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To github.com:tebeka/nlp.git
   8544121..fe1ffc4  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir stemmer                                                                                   Sun Apr 28, 15:14 
╭─miki@saitama  nlp (git:master) 
╰─$ cp ../data/stemmer.go stemmer                                                                   Sun Apr 28, 15:19 
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                            Sun Apr 28, 15:19 
.
├── example_test.go
├── go.mod
├── go.sum
├── nlp.go
├── nlp_test.go
└── stemmer
    └── stemmer.go

1 directory, 6 files╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:19 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- FAIL: TestTokenize (0.00s)
    --- FAIL: TestTokenize/Who's_on_first? (0.00s)
        require.go:157: 
            	Error Trace:	nlp_test.go:28
            	Error:      	Not equal: 
            	            	expected: []string{"who", "s", "on", "first"}
            	            	actual  : []string{"who", "", "on", "first"}
            	            	
            	            	Diff:
            	            	--- Expected
            	            	+++ Actual
            	            	@@ -2,3 +2,3 @@
            	            	  (string) (len=3) "who",
            	            	- (string) (len=1) "s",
            	            	+ (string) "",
            	            	  (string) (len=2) "on",
            	Test:       	TestTokenize/Who's_on_first?
            	Messages:   	tokenize
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- FAIL: ExampleTokenize (0.00s)
got:
[what  up doc]
want:
[what s up doc]
FAIL
exit status 1
FAIL	github.com/tebeka/nlp	0.003s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 15:23 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- FAIL: ExampleTokenize (0.00s)
got:
[what  up doc]
want:
[what s up doc]
FAIL
exit status 1
FAIL	github.com/tebeka/nlp	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 15:24 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- FAIL: ExampleTokenize (0.00s)
got:
[what up doc]
want:
[what s up doc]
FAIL
exit status 1
FAIL	github.com/tebeka/nlp	0.003s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                   Sun Apr 28, 15:25 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.003s
╭─miki@saitama  nlp (git:master) 
╰─$ git add stemmer                                                                                 Sun Apr 28, 15:25 
╭─miki@saitama  nlp (git:master) 
╰─$ git add -u                                                                                      Sun Apr 28, 15:27 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'stemming'                                                                        Sun Apr 28, 15:27 
[master 98bc5f9] stemming
 4 files changed, 27 insertions(+), 4 deletions(-)
 create mode 100644 stemmer/stemmer.go
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 15:27 Enumerating objects: 11, done.
Counting objects: 100% (11/11), done.
Delta compression using up to 4 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (7/7), 849 bytes | 849.00 KiB/s, done.
Total 7 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To github.com:tebeka/nlp.git
   fe1ffc4..98bc5f9  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ git tag v0.2.0                                                                                  Sun Apr 28, 15:27 
╭─miki@saitama  nlp (git:master) 
╰─$ git push --tags                                                                                 Sun Apr 28, 15:28 
Total 0 (delta 0), reused 0 (delta 0)
To github.com:tebeka/nlp.git
 * [new tag]         v0.2.0 -> v0.2.0
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v                                                                                      Sun Apr 28, 15:28 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v ./stemmer/stemmer_test.go                                                            Sun Apr 28, 15:41 
=== RUN   TestStem
--- PASS: TestStem (0.00s)
PASS
ok  	command-line-arguments	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v ./...                                                                                Sun Apr 28, 15:41 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
=== RUN   TestStem
--- PASS: TestStem (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	0.001s
╭─miki@saitama  nlp (git:master) 
╰─$go test -v ./...                                                                                Sun Apr 28, 15:41 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	(cached)
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v ./...                                                                                Sun Apr 28, 15:46 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	(cached)
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ git add stemmer/                                                                                Sun Apr 28, 15:47 
╭─miki@saitama  nlp (git:master) 
╰─$ git status -u                                                                                   Sun Apr 28, 15:47 
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   stemmer/stemmer_test.go

╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'stemmer tests'                                                                   Sun Apr 28, 15:47 
[master 51a140e] stemmer tests
 1 file changed, 26 insertions(+)
 create mode 100644 stemmer/stemmer_test.go
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 15:47 
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 4 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 575 bytes | 575.00 KiB/s, done.
Total 4 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:tebeka/nlp.git
   98bc5f9..51a140e  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v ./...                                                                                Sun Apr 28, 15:47 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	(cached)╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . ./...                                                                       Sun Apr 28, 16:01 
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
--- FAIL: BenchmarkTokenize
    nlp_test.go:62: [software engineer i what happen to programm when you add time and other programmer rus cox]
FAIL
exit status 1
FAIL	github.com/tebeka/nlp	0.003s
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . ./...                                                                    Sun Apr 28, 16:01 1 ↵
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  200000	      5133 ns/op
PASS
ok  	github.com/tebeka/nlp	1.132s
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	0.002s╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$' ./...                                                             Sun Apr 28, 16:02 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      5090 ns/op
PASS
ok  	github.com/tebeka/nlp	1.587s
PASS
ok  	github.com/tebeka/nlp/stemmer	0.002s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$' -cpuprofile=prof.out ./...                                        Sun Apr 28, 16:04 
cannot use -cpuprofile flag with multiple packages
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$' -cpuprofile=prof.out                                           Sun Apr 28, 16:04 1 ↵
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      5156 ns/op
PASS
ok  	github.com/tebeka/nlp	1.810s
╭─miki@saitama  nlp (git:master) 
╰─$ ls                                                                                              Sun Apr 28, 16:04 
example_test.go  go.mod  go.sum  nlp.go  nlp.test  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$go tool pprof prof.out                                                                          Sun Apr 28, 16:04 
File: nlp.test
Type: cpu
Time: Apr 28, 2019 at 4:04pm (IDT)
Duration: 1.80s, Total samples = 1.66s (92.10%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) help
  Commands:
    callgrind        Outputs a graph in callgrind format
    comments         Output all profile comments
    disasm           Output assembly listings annotated with samples
    dot              Outputs a graph in DOT format
    eog              Visualize graph through eog
    evince           Visualize graph through evince
    gif              Outputs a graph image in GIF format
    gv               Visualize graph through gv
    kcachegrind      Visualize report in KCachegrind
    list             Output annotated source for functions matching regexp
    pdf              Outputs a graph in PDF format
    peek             Output callers/callees of functions matching regexp
    png              Outputs a graph image in PNG format
    proto            Outputs the profile in compressed protobuf format
    ps               Outputs a graph in PS format
    raw              Outputs a text representation of the raw profile
    svg              Outputs a graph in SVG format
    tags             Outputs all tags in the profile
    text             Outputs top entries in text form
    top              Outputs top entries in text form
    topproto         Outputs top entries in compressed protobuf format
    traces           Outputs all profile samples in text form
    tree             Outputs a text rendering of call graph
    web              Visualize graph through web browser
    weblist          Display annotated source in a web browser
    o/options        List options and their current values
    quit/exit/^D     Exit pprof

  Options:
    call_tree        Create a context-sensitive call tree
    compact_labels   Show minimal headers
    divide_by        Ratio to divide all samples before visualization
    drop_negative    Ignore negative differences
    edgefraction     Hide edges below <f>*total
    focus            Restricts to samples going through a node matching regexp
    hide             Skips nodes matching regexp
    ignore           Skips paths going through any nodes matching regexp
    mean             Average sample value over first value (count)
    nodecount        Max number of nodes to show
    nodefraction     Hide nodes below <f>*total
    noinlines        Ignore inlines.
    normalize        Scales profile based on the base profile.
    output           Output filename for file-based outputs
    prune_from       Drops any functions below the matched frame.
    relative_percentages Show percentages relative to focused subgraph
    sample_index     Sample value to report (0-based index or name)
    show             Only show nodes matching regexp
    show_from        Drops functions above the highest matched frame.
    source_path      Search path for source files
    tagfocus         Restricts to samples with tags in range or matched by regexp
    taghide          Skip tags matching this regexp
    tagignore        Discard samples with tags in range or matched by regexp
    tagshow          Only consider tags matching this regexp
    trim             Honor nodefraction/edgefraction/nodecount defaults
    trim_path        Path to trim from source paths before search
    unit             Measurement units to display

  Option groups (only set one per group):
    cumulative       
      cum              Sort entries based on cumulative weight
      flat             Sort entries based on own weight
    granularity      
      addresses        Aggregate at the address level.
      filefunctions    Aggregate at the function level.
      files            Aggregate at the file level.
      functions        Aggregate at the function level.
      lines            Aggregate at the source code line level.
  :   Clear focus/ignore/hide/tagfocus/tagignore

  type "help <cmd|option>" for more information
(pprof)top 20
Showing nodes accounting for 1430ms, 86.14% of 1660ms total
Showing top 20 nodes out of 88
      flat  flat%   sum%        cum   cum%
     260ms 15.66% 15.66%      700ms 42.17%  regexp.(*Regexp).tryBacktrack
     160ms  9.64% 25.30%      160ms  9.64%  regexp.(*bitState).shouldVisit
     110ms  6.63% 31.93%      140ms  8.43%  regexp.(*bitState).push
     100ms  6.02% 37.95%     1180ms 71.08%  regexp.(*Regexp).backtrack
     100ms  6.02% 43.98%      100ms  6.02%  regexp/syntax.(*Inst).MatchRunePos
      70ms  4.22% 48.19%      130ms  7.83%  regexp.(*Regexp).FindAllString.func1
      70ms  4.22% 52.41%     1390ms 83.73%  regexp.(*Regexp).allMatches
      70ms  4.22% 56.63%       70ms  4.22%  regexp.(*inputString).step
      70ms  4.22% 60.84%      190ms 11.45%  runtime.mallocgc
      70ms  4.22% 65.06%      100ms  6.02%  strings.HasSuffix
      50ms  3.01% 68.07%      260ms 15.66%  runtime.growslice
      50ms  3.01% 71.08%       50ms  3.01%  runtime.memmove
      40ms  2.41% 73.49%       40ms  2.41%  runtime.procPin
      40ms  2.41% 75.90%       60ms  3.61%  strings.ToLower
      30ms  1.81% 77.71%       30ms  1.81%  runtime.heapBitsSetType
      30ms  1.81% 79.52%       30ms  1.81%  runtime.memclrNoHeapPointers
      30ms  1.81% 81.33%       30ms  1.81%  runtime.nextFreeFast
      30ms  1.81% 83.13%      110ms  6.63%  sync.(*Pool).Put
      30ms  1.81% 84.94%      100ms  6.02%  sync.(*Pool).pin
      20ms  1.20% 86.14%       20ms  1.20%  memeqbody
(pprof) list .Total: 1.66s
ROUTINE ======================== github.com/tebeka/nlp.BenchmarkTokenize in /home/miki/Teaching/the-daily-go/nlp/nlp_test.go
         0      1.63s (flat, cum) 98.19% of Total
         .          .     55:    - Russ Cox
         .          .     56:`
         .          .     57:
         .          .     58:func BenchmarkTokenize(b *testing.B) {
         .          .     59:	for i := 0; i < b.N; i++ {
         .      1.63s     60:		toks := Tokenize(tokBenchText)
         .          .     61:		if len(toks) != 16 {
         .          .     62:			b.Fatal(toks)
         .          .     63:		}
         .          .     64:	}
         .          .     65:}
ROUTINE ======================== github.com/tebeka/nlp.Tokenize in /home/miki/Teaching/the-daily-go/nlp/nlp.go
      10ms      1.63s (flat, cum) 98.19% of Total
         .          .     11:	wordRe = regexp.MustCompile("[[:alpha:]]+")
         .          .     12:)
         .          .     13:
         .          .     14:// Tokenize returns a slice of tokens found in text
         .          .     15:func Tokenize(text string) []string {
         .      1.39s     16:	words := wordRe.FindAllString(text, -1)
         .          .     17:	var tokens []string
         .          .     18:	for _, w := range words {
         .          .     19:		// TODO: stem
      10ms      170ms     20:		token := stemmer.Stem(strings.ToLower(w))
         .          .     21:		if token != "" {
         .       70ms     22:			tokens = append(tokens, token)
         .          .     23:		}
         .          .     24:	}
         .          .     25:	return tokens
         .          .     26:}
ROUTINE ======================== github.com/tebeka/nlp/stemmer.Stem in /home/miki/Teaching/the-daily-go/nlp/stemmer/stemmer.go
         0      100ms (flat, cum)  6.02% of Total
         .          .      9:)
         .          .     10:
         .          .     11:// Stem returns the stemmed version of word
         .          .     12:func Stem(word string) string {
         .          .     13:	for _, suffix := range suffixes {
         .      100ms     14:		if strings.HasSuffix(word, suffix) {
         .          .     15:			return word[:len(word)-len(suffix)]
         .          .     16:		}
         .          .     17:	}
         .          .     18:	return word
         .          .     19:}
ROUTINE ======================== memeqbody in /opt/go1.12.4/src/internal/bytealg/equal_amd64.s
      20ms       20ms (flat, cum)  1.20% of Total
         .          .    156:
         .          .    157:	// same for DI.
         .          .    158:	CMPB	DI, $0xf8
         .          .    159:	JA	di_high
         .          .    160:	MOVQ	(DI), DI
      10ms       10ms    161:	JMP	di_finish
         .          .    162:di_high:
         .          .    163:	MOVQ	-8(DI)(BX*1), DI
         .          .    164:	SHRQ	CX, DI
         .          .    165:di_finish:
         .          .    166:
         .          .    167:	SUBQ	SI, DI
         .          .    168:	SHLQ	CX, DI
         .          .    169:equal:
         .          .    170:	SETEQ	(AX)
      10ms       10ms    171:	RET
         .          .    172:
ROUTINE ======================== regexp.(*Regexp).FindAllString in /opt/go1.12.4/src/regexp/regexp.go
         0      1.39s (flat, cum) 83.73% of Total
         .          .   1055:func (re *Regexp) FindAllString(s string, n int) []string {
         .          .   1056:	if n < 0 {
         .          .   1057:		n = len(s) + 1
         .          .   1058:	}
         .          .   1059:	var result []string
         .      1.39s   1060:	re.allMatches(s, nil, n, func(match []int) {
         .          .   1061:		if result == nil {
         .          .   1062:			result = make([]string, 0, startSize)
         .          .   1063:		}
         .          .   1064:		result = append(result, s[match[0]:match[1]])
         .          .   1065:	})
ROUTINE ======================== regexp.(*Regexp).FindAllString.func1 in /opt/go1.12.4/src/regexp/regexp.go
      70ms      130ms (flat, cum)  7.83% of Total
         .          .   1055:func (re *Regexp) FindAllString(s string, n int) []string {
         .          .   1056:	if n < 0 {
         .          .   1057:		n = len(s) + 1
         .          .   1058:	}
         .          .   1059:	var result []string
      20ms       20ms   1060:	re.allMatches(s, nil, n, func(match []int) {
      10ms       10ms   1061:		if result == nil {
      10ms       20ms   1062:			result = make([]string, 0, startSize)
         .          .   1063:		}
      30ms       80ms   1064:		result = append(result, s[match[0]:match[1]])
         .          .   1065:	})
         .          .   1066:	return result
         .          .   1067:}
         .          .   1068:
         .          .   1069:// FindAllStringIndex is the 'All' version of FindStringIndex; it returns a
ROUTINE ======================== regexp.(*Regexp).allMatches in /opt/go1.12.4/src/regexp/regexp.go
      70ms      1.39s (flat, cum) 83.73% of Total
         .          .    713:		end = len(s)
         .          .    714:	} else {
         .          .    715:		end = len(b)
         .          .    716:	}
         .          .    717:
      20ms       20ms    718:	for pos, i, prevMatchEnd := 0, 0, -1; i < n && pos <= end; {
      10ms      1.20s    719:		matches := re.doExecute(nil, b, s, pos, re.prog.NumCap, nil)
         .          .    720:		if len(matches) == 0 {
         .          .    721:			break
         .          .    722:		}
         .          .    723:
         .          .    724:		accept := true
         .          .    725:		if matches[1] == pos {
         .          .    726:			// We've found an empty match.
      10ms       10ms    727:			if matches[0] == prevMatchEnd {
         .          .    728:				// We don't allow an empty match right
         .          .    729:				// after a previous match, so ignore it.
         .          .    730:				accept = false
         .          .    731:			}
         .          .    732:			var width int
         .          .    733:			// TODO: use step()
         .          .    734:			if b == nil {
         .          .    735:				_, width = utf8.DecodeRuneInString(s[pos:end])
         .          .    736:			} else {
         .          .    737:				_, width = utf8.DecodeRune(b[pos:end])
         .          .    738:			}
         .          .    739:			if width > 0 {
         .          .    740:				pos += width
         .          .    741:			} else {
         .          .    742:				pos = end + 1
         .          .    743:			}
         .          .    744:		} else {
         .          .    745:			pos = matches[1]
         .          .    746:		}
      10ms       10ms    747:		prevMatchEnd = matches[1]
         .          .    748:
         .          .    749:		if accept {
      20ms      150ms    750:			deliver(re.pad(matches))
         .          .    751:			i++
         .          .    752:		}
         .          .    753:	}
         .          .    754:}
         .          .    755:
ROUTINE ======================== regexp.(*Regexp).backtrack in /opt/go1.12.4/src/regexp/backtrack.go
     100ms      1.18s (flat, cum) 71.08% of Total
         .          .    303:	return longest && len(b.matchcap) > 1 && b.matchcap[1] >= 0
         .          .    304:}
         .          .    305:
         .          .    306:// backtrack runs a backtracking search of prog on the input starting at pos.
         .          .    307:func (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int {
      20ms       20ms    308:	startCond := re.cond
         .          .    309:	if startCond == ^syntax.EmptyOp(0) { // impossible
         .          .    310:		return nil
         .          .    311:	}
         .          .    312:	if startCond&syntax.EmptyBeginText != 0 && pos != 0 {
         .          .    313:		// Anchored match, past beginning of text.
         .          .    314:		return nil
         .          .    315:	}
         .          .    316:
         .       40ms    317:	b := newBitState()
         .          .    318:	i, end := b.inputs.init(nil, ib, is)
         .       30ms    319:	b.reset(re.prog, end, ncap)
         .          .    320:
         .          .    321:	// Anchored search must start at the beginning of the input
         .          .    322:	if startCond&syntax.EmptyBeginText != 0 {
         .          .    323:		if len(b.cap) > 0 {
         .          .    324:			b.cap[0] = pos
         .          .    325:		}
         .          .    326:		if !re.tryBacktrack(b, i, uint32(re.prog.Start), pos) {
         .          .    327:			freeBitState(b)
         .          .    328:			return nil
         .          .    329:		}
         .          .    330:	} else {
         .          .    331:
         .          .    332:		// Unanchored search, starting from each possible text position.
         .          .    333:		// Notice that we have to try the empty string at the end of
         .          .    334:		// the text, so the loop condition is pos <= end, not pos < end.
         .          .    335:		// This looks like it's quadratic in the size of the text,
         .          .    336:		// but we are not clearing visited between calls to TrySearch,
         .          .    337:		// so no work is duplicated and it ends up still being linear.
         .          .    338:		width := -1
      20ms       20ms    339:		for ; pos <= end && width != 0; pos += width {
      10ms       10ms    340:			if len(re.prefix) > 0 {
         .          .    341:				// Match requires literal prefix; fast search for it.
         .          .    342:				advance := i.index(re, pos)
         .          .    343:				if advance < 0 {
         .          .    344:					freeBitState(b)
         .          .    345:					return nil
         .          .    346:				}
         .          .    347:				pos += advance
         .          .    348:			}
         .          .    349:
         .          .    350:			if len(b.cap) > 0 {
         .          .    351:				b.cap[0] = pos
         .          .    352:			}
      20ms      720ms    353:			if re.tryBacktrack(b, i, uint32(re.prog.Start), pos) {
         .          .    354:				// Match must be leftmost; done.
         .          .    355:				goto Match
         .          .    356:			}
      10ms       20ms    357:			_, width = i.step(pos)
         .          .    358:		}
         .       40ms    359:		freeBitState(b)
         .          .    360:		return nil
         .          .    361:	}
         .          .    362:
         .          .    363:Match:
      20ms      210ms    364:	dstCap = append(dstCap, b.matchcap...)
         .       70ms    365:	freeBitState(b)
         .          .    366:	return dstCap
         .          .    367:}
ROUTINE ======================== regexp.(*Regexp).doExecute in /opt/go1.12.4/src/regexp/exec.go
      10ms      1.19s (flat, cum) 71.69% of Total
         .          .    516:
         .          .    517:// doExecute finds the leftmost match in the input, appends the position
         .          .    518:// of its subexpressions to dstCap and returns dstCap.
         .          .    519://
         .          .    520:// nil is returned if no matches are found and non-nil if matches are found.
      10ms       10ms    521:func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int {
         .          .    522:	if dstCap == nil {
         .          .    523:		// Make sure 'return dstCap' is non-nil.
         .          .    524:		dstCap = arrayNoInts[:0:0]
         .          .    525:	}
         .          .    526:
         .          .    527:	if re.onepass != nil {
         .          .    528:		return re.doOnePass(r, b, s, pos, ncap, dstCap)
         .          .    529:	}
         .          .    530:	if r == nil && len(b)+len(s) < re.maxBitStateLen {
         .      1.18s    531:		return re.backtrack(b, s, pos, ncap, dstCap)
         .          .    532:	}
         .          .    533:
         .          .    534:	m := re.get()
         .          .    535:	i, _ := m.inputs.init(r, b, s)
         .          .    536:
ROUTINE ======================== regexp.(*Regexp).tryBacktrack in /opt/go1.12.4/src/regexp/backtrack.go
     260ms      700ms (flat, cum) 42.17% of Total
         .          .    135:		b.jobs = append(b.jobs, job{pc: pc, arg: arg, pos: pos})
         .          .    136:	}
         .          .    137:}
         .          .    138:
         .          .    139:// tryBacktrack runs a backtracking search starting at pos.
      10ms       10ms    140:func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool {
         .          .    141:	longest := re.longest
         .          .    142:
         .      100ms    143:	b.push(re, pc, pos, false)
         .          .    144:	for len(b.jobs) > 0 {
         .          .    145:		l := len(b.jobs) - 1
         .          .    146:		// Pop job off the stack.
         .          .    147:		pc := b.jobs[l].pc
      10ms       10ms    148:		pos := b.jobs[l].pos
         .          .    149:		arg := b.jobs[l].arg
      10ms       10ms    150:		b.jobs = b.jobs[:l]
         .          .    151:
         .          .    152:		// Optimization: rather than push and pop,
         .          .    153:		// code that is going to Push and continue
         .          .    154:		// the loop simply updates ip, p, and arg
         .          .    155:		// and jumps to CheckAndLoop. We have to
         .          .    156:		// do the ShouldVisit check that Push
         .          .    157:		// would have, but we avoid the stack
         .          .    158:		// manipulation.
         .          .    159:		goto Skip
         .          .    160:	CheckAndLoop:
      20ms      150ms    161:		if !b.shouldVisit(pc, pos) {
         .          .    162:			continue
         .          .    163:		}
         .          .    164:	Skip:
         .          .    165:
     130ms      130ms    166:		inst := re.prog.Inst[pc]
         .          .    167:
      30ms       30ms    168:		switch inst.Op {
         .          .    169:		default:
         .          .    170:			panic("bad inst")
         .          .    171:		case syntax.InstFail:
         .          .    172:			panic("unexpected InstFail")
         .          .    173:		case syntax.InstAlt:
         .          .    174:			// Cannot just
         .          .    175:			//   b.push(inst.Out, pos, false)
         .          .    176:			//   b.push(inst.Arg, pos, false)
         .          .    177:			// If during the processing of inst.Out, we encounter
         .          .    178:			// inst.Arg via another path, we want to process it then.
         .          .    179:			// Pushing it here will inhibit that. Instead, re-push
         .          .    180:			// inst with arg==true as a reminder to push inst.Arg out
         .          .    181:			// later.
         .          .    182:			if arg {
         .          .    183:				// Finished inst.Out; try inst.Arg.
         .          .    184:				arg = false
         .          .    185:				pc = inst.Arg
         .          .    186:				goto CheckAndLoop
         .          .    187:			} else {
         .       40ms    188:				b.push(re, pc, pos, true)
         .          .    189:				pc = inst.Out
         .          .    190:				goto CheckAndLoop
         .          .    191:			}
         .          .    192:
         .          .    193:		case syntax.InstAltMatch:
         .          .    194:			// One opcode consumes runes; the other leads to match.
         .          .    195:			switch re.prog.Inst[inst.Out].Op {
         .          .    196:			case syntax.InstRune, syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
         .          .    197:				// inst.Arg is the match.
         .          .    198:				b.push(re, inst.Arg, pos, false)
                   .    199:				pc = inst.Arg
         .          .    200:				pos = b.end
         .          .    201:				goto CheckAndLoop
         .          .    202:			}
         .          .    203:			// inst.Out is the match - non-greedy
         .          .    204:			b.push(re, inst.Out, b.end, false)
         .          .    205:			pc = inst.Out
         .          .    206:			goto CheckAndLoop
         .          .    207:
         .          .    208:		case syntax.InstRune:
      10ms       70ms    209:			r, width := i.step(pos)
         .      110ms    210:			if !inst.MatchRune(r) {
         .          .    211:				continue
         .          .    212:			}
      10ms       10ms    213:			pos += width
         .          .    214:			pc = inst.Out
         .          .    215:			goto CheckAndLoop
         .          .    216:
         .          .    217:		case syntax.InstRune1:
         .          .    218:			r, width := i.step(pos)
         .          .    219:			if r != inst.Rune[0] {
         .          .    220:				continue
         .          .    221:			}
         .          .    222:			pos += width
         .          .    223:			pc = inst.Out
         .          .    224:			goto CheckAndLoop
         .          .    225:
         .          .    226:		case syntax.InstRuneAnyNotNL:
         .          .    227:			r, width := i.step(pos)
         .          .    228:			if r == '\n' || r == endOfText {
         .          .    229:				continue
         .          .    230:			}
         .          .    231:			pos += width
         .          .    232:			pc = inst.Out
         .          .    233:			goto CheckAndLoop
         .          .    234:
         .          .    235:		case syntax.InstRuneAny:
         .          .    236:			r, width := i.step(pos)
         .          .    237:			if r == endOfText {
         .          .    238:				continue
         .          .    239:			}
         .          .    240:			pos += width
         .          .    241:			pc = inst.Out
         .          .    242:			goto CheckAndLoop
         .          .    243:
         .          .    244:		case syntax.InstCapture:
      20ms       20ms    245:			if arg {
         .          .    246:				// Finished inst.Out; restore the old value.
         .          .    247:				b.cap[inst.Arg] = pos
         .          .    248:				continue
         .          .    249:			} else {
         .          .    250:				if 0 <= inst.Arg && inst.Arg < uint32(len(b.cap)) {
         .          .    251:					// Capture pos to register, but save old value.
         .          .    252:					b.push(re, pc, b.cap[inst.Arg], true) // come back when we're done.
         .          .    253:					b.cap[inst.Arg] = pos
         .          .    254:				}
         .          .    255:				pc = inst.Out
         .          .    256:				goto CheckAndLoop
         .          .    257:			}
         .          .    258:
         .          .    259:		case syntax.InstEmptyWidth:
         .          .    260:			flag := i.context(pos)
         .          .    261:			if !flag.match(syntax.EmptyOp(inst.Arg)) {
         .          .    262:				continue
         .          .    263:			}
         .          .    264:			pc = inst.Out
         .          .    265:			goto CheckAndLoop
         .          .    266:
      10ms       10ms    267:		case syntax.InstNop:
         .          .    268:			pc = inst.Out
         .          .    269:			goto CheckAndLoop
         .          .    270:
         .          .    271:		case syntax.InstMatch:
         .          .    272:			// We found a match. If the caller doesn't care
ROUTINE ======================== regexp.(*bitState).push in /opt/go1.12.4/src/regexp/backtrack.go
     110ms      140ms (flat, cum)  8.43% of Total
         .          .    129:// push pushes (pc, pos, arg) onto the job stack if it should be
         .          .    130:// visited.
         .          .    131:func (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool) {
         .          .    132:	// Only check shouldVisit when arg is false.
         .          .    133:	// When arg is true, we are continuing a previous visit.
      40ms       70ms    134:	if re.prog.Inst[pc].Op != syntax.InstFail && (arg || b.shouldVisit(pc, pos)) {
      70ms       70ms    135:		b.jobs = append(b.jobs, job{pc: pc, arg: arg, pos: pos})
         .          .    136:	}
         .          .    137:}
         .          .    138:
         .          .    139:// tryBacktrack runs a backtracking search starting at pos.
         .          .    140:func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool {
ROUTINE ======================== regexp.(*bitState).reset in /opt/go1.12.4/src/regexp/backtrack.go
      20ms       30ms (flat, cum)  1.81% of Total
         .          .     89:	visitedSize := (len(prog.Inst)*(end+1) + visitedBits - 1) / visitedBits
         .          .     90:	if cap(b.visited) < visitedSize {
         .          .     91:		b.visited = make([]uint32, visitedSize, maxBacktrackVector/visitedBits)
         .          .     92:	} else {
         .          .     93:		b.visited = b.visited[:visitedSize]
         .       10ms     94:		for i := range b.visited {
         .          .     95:			b.visited[i] = 0
         .          .     96:		}
         .          .     97:	}
         .          .     98:
         .          .     99:	if cap(b.cap) < ncap {
         .          .    100:		b.cap = make([]int, ncap)
         .          .    101:	} else {
         .          .    102:		b.cap = b.cap[:ncap]
         .          .    103:	}
         .          .    104:	for i := range b.cap {
         .          .    105:		b.cap[i] = -1
         .          .    106:	}
         .          .    107:
         .          .    108:	if cap(b.matchcap) < ncap {
         .          .    109:		b.matchcap = make([]int, ncap)
         .          .    110:	} else {
      20ms       20ms    111:		b.matchcap = b.matchcap[:ncap]
         .          .    112:	}
         .          .    113:	for i := range b.matchcap {
         .          .    114:		b.matchcap[i] = -1
         .          .    115:	}
         .          .    116:}
ROUTINE ======================== regexp.(*bitState).shouldVisit in /opt/go1.12.4/src/regexp/backtrack.go
     160ms      160ms (flat, cum)  9.64% of Total
         .          .    116:}
         .          .    117:
         .          .    118:// shouldVisit reports whether the combination of (pc, pos) has not
         .          .    119:// been visited yet.
         .          .    120:func (b *bitState) shouldVisit(pc uint32, pos int) bool {
      50ms       50ms    121:	n := uint(int(pc)*(b.end+1) + pos)
      60ms       60ms    122:	if b.visited[n/visitedBits]&(1<<(n&(visitedBits-1))) != 0 {
         .          .    123:		return false
         .          .    124:	}
      50ms       50ms    125:	b.visited[n/visitedBits] |= 1 << (n & (visitedBits - 1))
         .          .    126:	return true
         .          .    127:}
         .          .    128:
         .          .    129:// push pushes (pc, pos, arg) onto the job stack if it should be
         .          .    130:// visited.
ROUTINE ======================== regexp.(*inputString).step in /opt/go1.12.4/src/regexp/regexp.go
      70ms       70ms (flat, cum)  4.22% of Total
         .          .    321:// inputString scans a string.
         .          .    322:type inputString struct {
         .          .    323:	str string
         .          .    324:}
         .          .    325:
      20ms       20ms    326:func (i *inputString) step(pos int) (rune, int) {
      10ms       10ms    327:	if pos < len(i.str) {
      20ms       20ms    328:		c := i.str[pos]
         .          .    329:		if c < utf8.RuneSelf {
      20ms       20ms    330:			return rune(c), 1
         .          .    331:		}
         .          .    332:		return utf8.DecodeRuneInString(i.str[pos:])
         .          .    333:	}
         .          .    334:	return endOfText, 0
         .          .    335:}
ROUTINE ======================== regexp.freeBitState in /opt/go1.12.4/src/regexp/backtrack.go
         0      110ms (flat, cum)  6.63% of Total
         .          .     54:	return b
         .          .     55:}
         .          .     56:
         .          .     57:func freeBitState(b *bitState) {
         .          .     58:	b.inputs.clear()
         .      110ms     59:	bitStatePool.Put(b)
         .          .     60:}
         .          .     61:
         .          .     62:// maxBitStateLen returns the maximum length of a string to search with
         .          .     63:// the backtracker using prog.
         .          .     64:func maxBitStateLen(prog *syntax.Prog) int {
ROUTINE ======================== regexp.newBitState in /opt/go1.12.4/src/regexp/backtrack.go
         0       40ms (flat, cum)  2.41% of Total
         .          .     45:}
         .          .     46:
         .          .     47:var bitStatePool sync.Pool
         .          .     48:
         .          .     49:func newBitState() *bitState {
         .       40ms     50:	b, ok := bitStatePool.Get().(*bitState)
         .          .     51:	if !ok {
         .          .     52:		b = new(bitState)
         .          .     53:	}
         .          .     54:	return b
         .          .     55:}
ROUTINE ======================== regexp/syntax.(*Inst).MatchRune in /opt/go1.12.4/src/regexp/syntax/prog.go
      10ms      110ms (flat, cum)  6.63% of Total
         .          .    188:const noMatch = -1
         .          .    189:
         .          .    190:// MatchRune reports whether the instruction matches (and consumes) r.
         .          .    191:// It should only be called when i.Op == InstRune.
         .          .    192:func (i *Inst) MatchRune(r rune) bool {
      10ms      110ms    193:	return i.MatchRunePos(r) != noMatch
         .          .    194:}
         .          .    195:
         .          .    196:// MatchRunePos checks whether the instruction matches (and consumes) r.
         .          .    197:// If so, MatchRunePos returns the index of the matching rune pair
         .          .    198:// (or, when len(i.Rune) == 1, rune singleton).
ROUTINE ======================== regexp/syntax.(*Inst).MatchRunePos in /opt/go1.12.4/src/regexp/syntax/prog.go
     100ms      100ms (flat, cum)  6.02% of Total
         .          .    196:// MatchRunePos checks whether the instruction matches (and consumes) r.
         .          .    197:// If so, MatchRunePos returns the index of the matching rune pair
         .          .    198:// (or, when len(i.Rune) == 1, rune singleton).
         .          .    199:// If not, MatchRunePos returns -1.
         .          .    200:// MatchRunePos should only be called when i.Op == InstRune.
      10ms       10ms    201:func (i *Inst) MatchRunePos(r rune) int {
         .          .    202:	rune := i.Rune
         .          .    203:
         .          .    204:	switch len(rune) {
         .          .    205:	case 0:
         .          .    206:		return noMatch
         .          .    207:
         .          .    208:	case 1:
         .          .    209:		// Special case: single-rune slice is from literal string, not char class.
         .          .    210:		r0 := rune[0]
         .          .    211:		if r == r0 {
         .          .    212:			return 0
         .          .    213:		}
         .          .    214:		if Flags(i.Arg)&FoldCase != 0 {
         .          .    215:			for r1 := unicode.SimpleFold(r0); r1 != r0; r1 = unicode.SimpleFold(r1) {
         .          .    216:				if r == r1 {
         .          .    217:					return 0
         .          .    218:				}
         .          .    219:			}
         .          .    220:		}
         .          .    221:		return noMatch
         .          .    222:
         .          .    223:	case 2:
         .          .    224:		if r >= rune[0] && r <= rune[1] {
         .          .    225:			return 0
         .          .    226:		}
         .          .    227:		return noMatch
         .          .    228:
         .          .    229:	case 4, 6, 8:
         .          .    230:		// Linear search for a few pairs.
         .          .    231:		// Should handle ASCII well.
         .          .    232:		for j := 0; j < len(rune); j += 2 {
      20ms       20ms    233:			if r < rune[j] {
      20ms       20ms    234:				return noMatch
         .          .    235:			}
      50ms       50ms    236:			if r <= rune[j+1] {
         .          .    237:				return j / 2
         .          .    238:			}
         .          .    239:		}
         .          .    240:		return noMatch
         .          .    241:	}
ROUTINE ======================== runtime.(*gcBitsArena).tryAlloc in /opt/go1.12.4/src/runtime/mheap.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .   1818:}
         .          .   1819:
         .          .   1820:// tryAlloc allocates from b or returns nil if b does not have enough room.
         .          .   1821:// This is safe to call concurrently.
         .          .   1822:func (b *gcBitsArena) tryAlloc(bytes uintptr) *gcBits {
      10ms       10ms   1823:	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
         .          .   1824:		return nil
         .          .   1825:	}
         .          .   1826:	// Try to allocate from this block.
         .          .   1827:	end := atomic.Xadduintptr(&b.free, bytes)
         .          .   1828:	if end > uintptr(len(b.bits)) {
ROUTINE ======================== runtime.(*mcache).nextFree in /opt/go1.12.4/src/runtime/malloc.go
         0       30ms (flat, cum)  1.81% of Total
         .          .    781:		// The span is full.
         .          .    782:		if uintptr(s.allocCount) != s.nelems {
         .          .    783:			println("runtime: s.allocCount=", s.allocCount, "s.nelems=", s.nelems)
         .          .    784:			throw("s.allocCount != s.nelems && freeIndex == s.nelems")
         .          .    785:		}
         .       30ms    786:		c.refill(spc)
         .          .    787:		shouldhelpgc = true
         .          .    788:		s = c.alloc[spc]
         .          .    789:
         .          .    790:		freeIndex = s.nextFreeIndex()
         .          .    791:	}
ROUTINE ======================== runtime.(*mcache).refill in /opt/go1.12.4/src/runtime/mcache.go
         0       30ms (flat, cum)  1.81% of Total
         .          .    130:		}
         .          .    131:		atomic.Store(&s.sweepgen, mheap_.sweepgen)
         .          .    132:	}
         .          .    133:
         .          .    134:	// Get a new cached span from the central lists.
         .       30ms    135:	s = mheap_.central[spc].mcentral.cacheSpan()
         .          .    136:	if s == nil {
         .          .    137:		throw("out of memory")
         .          .    138:	}
         .          .    139:
         .          .    140:	if uintptr(s.allocCount) == s.nelems {
ROUTINE ======================== runtime.(*mcentral).cacheSpan in /opt/go1.12.4/src/runtime/mcentral.go
         0       30ms (flat, cum)  1.81% of Total
         .          .     75:			// sweep it and see if we can free some space in it
         .          .     76:			c.empty.remove(s)
         .          .     77:			// swept spans are at the end of the list
         .          .     78:			c.empty.insertBack(s)
         .          .     79:			unlock(&c.lock)
         .       10ms     80:			s.sweep(true)
         .          .     81:			freeIndex := s.nextFreeIndex()
         .          .     82:			if freeIndex != s.nelems {
         .          .     83:				s.freeindex = freeIndex
         .          .     84:				goto havespan
         .          .     85:			}
         .          .     86:			lock(&c.lock)
         .          .     87:			// the span is still empty after sweep
         .          .     88:			// it is already in the empty list, so just retry
         .          .     89:			goto retry
         .          .     90:		}
         .          .     91:		if s.sweepgen == sg-1 {
         .          .     92:			// the span is being swept by background sweeper, skip
         .          .     93:			continue
         .          .     94:		}
         .          .     95:		// already swept empty span,
         .          .     96:		// all subsequent ones must also be either swept or in process of sweeping
         .          .     97:		break
         .          .     98:	}
         .          .     99:	if trace.enabled {
         .          .    100:		traceGCSweepDone()
         .          .    101:		traceDone = true
         .          .    102:	}
         .          .    103:	unlock(&c.lock)
         .          .    104:
         .          .    105:	// Replenish central list if empty.
         .       20ms    106:	s = c.grow()
         .          .    107:	if s == nil {
         .          .    108:		return nil
         .          .    109:	}
         .          .    110:	lock(&c.lock)
         .          .    111:	c.empty.insertBack(s)
ROUTINE ======================== runtime.(*mcentral).freeSpan in /opt/go1.12.4/src/runtime/mcentral.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    241:		return false
         .          .    242:	}
         .          .    243:
         .          .    244:	c.nonempty.remove(s)
         .          .    245:	unlock(&c.lock)
         .       10ms    246:	mheap_.freeSpan(s, false)
         .          .    247:	return true
         .          .    248:}
         .          .    249:
         .          .    250:// grow allocates a new empty span from the heap and initializes it for c's size class.
         .          .    251:func (c *mcentral) grow() *mspan {
ROUTINE ======================== runtime.(*mcentral).grow in /opt/go1.12.4/src/runtime/mcentral.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    251:func (c *mcentral) grow() *mspan {
         .          .    252:	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
         .          .    253:	size := uintptr(class_to_size[c.spanclass.sizeclass()])
         .          .    254:	n := (npages << _PageShift) / size
         .          .    255:
         .       20ms    256:	s := mheap_.alloc(npages, c.spanclass, false, true)
         .          .    257:	if s == nil {
         .          .    258:		return nil
         .          .    259:	}
         .          .    260:
         .          .    261:	p := s.base()
ROUTINE ======================== runtime.(*mheap).alloc in /opt/go1.12.4/src/runtime/mheap.go
         0       20ms (flat, cum)  1.20% of Total
         .          .   1048:		s = h.alloc_m(npage, spanclass, large)
         .          .   1049:	})
         .          .   1050:
         .          .   1051:	if s != nil {
         .          .   1052:		if needzero && s.needzero != 0 {
         .       20ms   1053:			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages<<_PageShift)
         .          .   1054:		}
         .          .   1055:		s.needzero = 0
         .          .   1056:	}
         .          .   1057:	return s
         .          .   1058:}
ROUTINE ======================== runtime.(*mheap).freeSpan in /opt/go1.12.4/src/runtime/mheap.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1258:// Free the span back into the heap.
         .          .   1259://
         .          .   1260:// large must match the value of large passed to mheap.alloc. This is
         .          .   1261:// used for accounting.
         .          .   1262:func (h *mheap) freeSpan(s *mspan, large bool) {
         .       10ms   1263:	systemstack(func() {
         .          .   1264:		mp := getg().m
         .          .   1265:		lock(&h.lock)
         .          .   1266:		memstats.heap_scan += uint64(mp.mcache.local_scan)
         .          .   1267:		mp.mcache.local_scan = 0
         .          .   1268:		memstats.tinyallocs += uint64(mp.mcache.local_tinyallocs)
ROUTINE ======================== runtime.(*mheap).freeSpan.func1 in /opt/go1.12.4/src/runtime/mheap.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1260:// large must match the value of large passed to mheap.alloc. This is
         .          .   1261:// used for accounting.
         .          .   1262:func (h *mheap) freeSpan(s *mspan, large bool) {
         .          .   1263:	systemstack(func() {
         .          .   1264:		mp := getg().m
         .       10ms   1265:		lock(&h.lock)
         .          .   1266:		memstats.heap_scan += uint64(mp.mcache.local_scan)
         .          .   1267:		mp.mcache.local_scan = 0
         .          .   1268:		memstats.tinyallocs += uint64(mp.mcache.local_tinyallocs)
         .          .   1269:		mp.mcache.local_tinyallocs = 0
         .          .   1270:		if msanenabled {
ROUTINE ======================== runtime.(*mspan).sweep in /opt/go1.12.4/src/runtime/mgcsweep.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    337:	}
         .          .    338:
         .          .    339:	// gcmarkBits becomes the allocBits.
         .          .    340:	// get a fresh cleared gcmarkBits in preparation for next GC
         .          .    341:	s.allocBits = s.gcmarkBits
         .       10ms    342:	s.gcmarkBits = newMarkBits(s.nelems)
         .          .    343:
         .          .    344:	// Initialize alloc bits cache.
         .          .    345:	s.refillAllocCache(0)
         .          .    346:
         .          .    347:	// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,
         .          .    348:	// because of the potential for a concurrent free/SetFinalizer.
         .          .    349:	// But we need to set it before we make the span available for allocation
         .          .    350:	// (return it to heap or mcentral), because allocation code assumes that a
         .          .    351:	// span is already swept if available for allocation.
         .          .    352:	if freeToHeap || nfreed == 0 {
         .          .    353:		// The span must be in our exclusive ownership until we update sweepgen,
         .          .    354:		// check for potential races.
         .          .    355:		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
         .          .    356:			print("mspan.sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
         .          .    357:			throw("mspan.sweep: bad span state after sweep")
         .          .    358:		}
         .          .    359:		// Serialization point.
         .          .    360:		// At this point the mark bits are cleared and allocation ready
         .          .    361:		// to go so release the span.
         .          .    362:		atomic.Store(&s.sweepgen, sweepgen)
         .          .    363:	}
         .          .    364:
         .          .    365:	if nfreed > 0 && spc.sizeclass() != 0 {
         .          .    366:		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
         .       10ms    367:		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
         .          .    368:		// mcentral.freeSpan updates sweepgen
         .          .    369:	} else if freeToHeap {
         .          .    370:		// Free large span to heap
         .          .    371:
         .          .    372:		// NOTE(rsc,dvyukov): The original implementation of efence
ROUTINE ======================== runtime.bgsweep in /opt/go1.12.4/src/runtime/mgcsweep.go
         0       10ms (flat, cum)   0.6% of Total
         .          .     68:	sweep.parked = true
         .          .     69:	c <- 1
         .          .     70:	goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1)
         .          .     71:
         .          .     72:	for {
         .       10ms     73:		for sweepone() != ^uintptr(0) {
         .          .     74:			sweep.nbgsweep++
         .          .     75:			Gosched()
         .          .     76:		}
         .          .     77:		for freeSomeWbufs(true) {
         .          .     78:			Gosched()
ROUTINE ======================== runtime.callers in /opt/go1.12.4/src/runtime/traceback.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    808:func callers(skip int, pcbuf []uintptr) int {
         .          .    809:	sp := getcallersp()
         .          .    810:	pc := getcallerpc()
         .          .    811:	gp := getg()
         .          .    812:	var n int
         .       10ms    813:	systemstack(func() {
         .          .    814:		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
         .          .    815:	})
         .          .    816:	return n
         .          .    817:}
         .          .    818:
ROUTINE ======================== runtime.callers.func1 in /opt/go1.12.4/src/runtime/traceback.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    809:	sp := getcallersp()
         .          .    810:	pc := getcallerpc()
         .          .    811:	gp := getg()
         .          .    812:	var n int
         .          .    813:	systemstack(func() {
         .       10ms    814:		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
         .          .    815:	})
         .          .    816:	return n
         .          .    817:}
         .          .    818:
         .          .    819:func gcallers(gp *g, skip int, pcbuf []uintptr) int {
ROUTINE ======================== runtime.findObject in /opt/go1.12.4/src/runtime/mbitmap.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    360:// in which the pointer p was found and the byte offset at which it
         .          .    361:// was found. These are used for error reporting.
         .          .    362:func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr) {
         .          .    363:	s = spanOf(p)
         .          .    364:	// If p is a bad pointer, it may not be in s's bounds.
      10ms       10ms    365:	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
         .          .    366:		if s == nil || s.state == mSpanManual {
         .          .    367:			// If s is nil, the virtual address has never been part of the heap.
         .          .    368:			// This pointer may be to some mmap'd region, so we allow it.
         .          .    369:			// Pointers into stacks are also ok, the runtime manages these explicitly.
         .          .    370:			return
ROUTINE ======================== runtime.funcspdelta in /opt/go1.12.4/src/runtime/symtab.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    751:func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
         .          .    752:	return funcline1(f, targetpc, true)
         .          .    753:}
         .          .    754:
         .          .    755:func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
         .       10ms    756:	x := pcvalue(f, f.pcsp, targetpc, cache, true)
         .          .    757:	if x&(sys.PtrSize-1) != 0 {
         .          .    758:		print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")
         .          .    759:	}
         .          .    760:	return x
         .          .    761:}
ROUTINE ======================== runtime.futex in /opt/go1.12.4/src/runtime/sys_linux_amd64.s
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    531:	MOVQ	ts+16(FP), R10
         .          .    532:	MOVQ	addr2+24(FP), R8
         .          .    533:	MOVL	val3+32(FP), R9
         .          .    534:	MOVL	$SYS_futex, AX
         .          .    535:	SYSCALL
      10ms       10ms    536:	MOVL	AX, ret+40(FP)
         .          .    537:	RET
         .          .    538:
         .          .    539:// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
         .          .    540:TEXT runtime·clone(SB),NOSPLIT,$0
         .          .    541:	MOVL	flags+0(FP), DI
ROUTINE ======================== runtime.futexwakeup in /opt/go1.12.4/src/runtime/os_linux.go
         0       10ms (flat, cum)   0.6% of Total
         .          .     64:}
         .          .     65:
         .          .     66:// If any procs are sleeping on addr, wake up at most cnt.
         .          .     67://go:nosplit
         .          .     68:func futexwakeup(addr *uint32, cnt uint32) {
         .       10ms     69:	ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE_PRIVATE, cnt, nil, nil, 0)
         .          .     70:	if ret >= 0 {
         .          .     71:		return
         .          .     72:	}
         .          .     73:
         .          .     74:	// I don't know that futex wakeup can return
ROUTINE ======================== runtime.gcAssistAlloc in /opt/go1.12.4/src/runtime/mgcmark.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    417:		traced = true
         .          .    418:		traceGCMarkAssistStart()
         .          .    419:	}
         .          .    420:
         .          .    421:	// Perform assist work
         .       20ms    422:	systemstack(func() {
         .          .    423:		gcAssistAlloc1(gp, scanWork)
         .          .    424:		// The user stack may have moved, so this can't touch
         .          .    425:		// anything on it until it returns from systemstack.
         .          .    426:	})
         .          .    427:
ROUTINE ======================== runtime.gcAssistAlloc.func1 in /opt/go1.12.4/src/runtime/mgcmark.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    418:		traceGCMarkAssistStart()
         .          .    419:	}
         .          .    420:
         .          .    421:	// Perform assist work
         .          .    422:	systemstack(func() {
         .       20ms    423:		gcAssistAlloc1(gp, scanWork)
         .          .    424:		// The user stack may have moved, so this can't touch
         .          .    425:		// anything on it until it returns from systemstack.
         .          .    426:	})
         .          .    427:
         .          .    428:	completed := gp.param != nil
ROUTINE ======================== runtime.gcAssistAlloc1 in /opt/go1.12.4/src/runtime/mgcmark.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    507:	gp.waitreason = waitReasonGCAssistMarking
         .          .    508:
         .          .    509:	// drain own cached work first in the hopes that it
         .          .    510:	// will be more cache friendly.
         .          .    511:	gcw := &getg().m.p.ptr().gcw
         .       20ms    512:	workDone := gcDrainN(gcw, scanWork)
         .          .    513:
         .          .    514:	casgstatus(gp, _Gwaiting, _Grunning)
         .          .    515:
         .          .    516:	// Record that we did this much scan work.
         .          .    517:	//
ROUTINE ======================== runtime.gcBgMarkWorker in /opt/go1.12.4/src/runtime/mgc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1885:		if decnwait == work.nproc {
         .          .   1886:			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
         .          .   1887:			throw("work.nwait was > work.nproc")
         .          .   1888:		}
         .          .   1889:
         .       10ms   1890:		systemstack(func() {
         .          .   1891:			// Mark our goroutine preemptible so its stack
         .          .   1892:			// can be scanned. This lets two mark workers
         .          .   1893:			// scan each other (otherwise, they would
         .          .   1894:			// deadlock). We must not modify anything on
         .          .   1895:			// the G stack. However, stack shrinking is
ROUTINE ======================= runtime.gcBgMarkWorker.func2 in /opt/go1.12.4/src/runtime/mgc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1921:				// without preemption.
         .          .   1922:				gcDrain(&_p_.gcw, gcDrainFlushBgCredit)
         .          .   1923:			case gcMarkWorkerFractionalMode:
         .          .   1924:				gcDrain(&_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)
         .          .   1925:			case gcMarkWorkerIdleMode:
         .       10ms   1926:				gcDrain(&_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
         .          .   1927:			}
         .          .   1928:			casgstatus(gp, _Gwaiting, _Grunning)
         .          .   1929:		})
         .          .   1930:
         .          .   1931:		// Account for time.
ROUTINE ======================== runtime.gcDrain in /opt/go1.12.4/src/runtime/mgcmark.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    927:		}
         .          .    928:		if b == 0 {
         .          .    929:			// Unable to get work.
         .          .    930:			break
         .          .    931:		}
         .       10ms    932:		scanobject(b, gcw)
         .          .    933:
         .          .    934:		// Flush background scan work credit to the global
         .          .    935:		// account if we've accumulated enough locally so
         .          .    936:		// mutator assists can draw on it.
         .          .    937:		if gcw.scanWork >= gcCreditSlack {
ROUTINE ======================== runtime.gcDrainN in /opt/go1.12.4/src/runtime/mgcmark.go
         0       20ms (flat, cum)  1.20% of Total
         .          .   1021:				}
         .          .   1022:			}
         .          .   1023:			// No heap or root jobs.
         .          .   1024:			break
         .          .   1025:		}
         .       20ms   1026:		scanobject(b, gcw)
         .          .   1027:
         .          .   1028:		// Flush background scan work credit.
         .          .   1029:		if gcw.scanWork >= gcCreditSlack {
         .          .   1030:			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
         .          .   1031:			workFlushed += gcw.scanWork
ROUTINE ======================== runtime.gcWriteBarrier in /opt/go1.12.4/src/runtime/asm_amd64.s
         0       20ms (flat, cum)  1.20% of Total
         .          .   1419:	// R13 already saved
         .          .   1420:	// R14 already saved
         .          .   1421:	MOVQ	R15, 96(SP)
         .          .   1422:
         .          .   1423:	// This takes arguments DI and AX
         .       20ms   1424:	CALL	runtime·wbBufFlush(SB)
         .          .   1425:
         .          .   1426:	MOVQ	0(SP), DI
         .          .   1427:	MOVQ	8(SP), AX
         .          .   1428:	MOVQ	16(SP), BX
         .          .   1429:	MOVQ	24(SP), CX
ROUTINE ======================== runtime.gentraceback in /opt/go1.12.4/src/runtime/traceback.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    217:					// stack transition.
         .          .    218:					frame.sp = gp.m.curg.sched.sp
         .          .    219:					cgoCtxt = gp.m.curg.cgoCtxt
         .          .    220:				}
         .          .    221:			}
         .       10ms    222:			frame.fp = frame.sp + uintptr(funcspdelta(f, frame.pc, &cache))
         .          .    223:			if !usesLR {
         .          .    224:				// On x86, call instruction pushes return PC before entering new function.
         .          .    225:				frame.fp += sys.RegSize
         .          .    226:			}
         .          .    227:		}
ROUTINE ======================== runtime.gopreempt_m in /opt/go1.12.4/src/runtime/proc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   2643:
         .          .   2644:func gopreempt_m(gp *g) {
         .          .   2645:	if trace.enabled {
         .          .   2646:		traceGoPreempt()
         .          .   2647:	}
         .       10ms   2648:	goschedImpl(gp)
         .          .   2649:}
         .          .   2650:
         .          .   2651:// Finishes execution of the current goroutine.
         .          .   2652:func goexit1() {
         .          .   2653:	if raceenabled {
ROUTINE ======================== runtime.goschedImpl in /opt/go1.12.4/src/runtime/proc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   2615:	dropg()
         .          .   2616:	lock(&sched.lock)
         .          .   2617:	globrunqput(gp)
         .          .   2618:	unlock(&sched.lock)
         .          .   2619:
         .       10ms   2620:	schedule()
         .          .   2621:}
         .          .   2622:
         .          .   2623:// Gosched continuation on g0.
         .          .   2624:func gosched_m(gp *g) {
         .          .   2625:	if trace.enabled {
ROUTINE ======================== runtime.greyobject in /opt/go1.12.4/src/runtime/mgcmark.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1242:			return
         .          .   1243:		}
         .          .   1244:		mbits.setMarked()
         .          .   1245:
         .          .   1246:		// Mark span.
         .       10ms   1247:		arena, pageIdx, pageMask := pageIndexOf(span.base())
         .          .   1248:		if arena.pageMarks[pageIdx]&pageMask == 0 {
         .          .   1249:			atomic.Or8(&arena.pageMarks[pageIdx], pageMask)
         .          .   1250:		}
         .          .   1251:
         .          .   1252:		// If this is a noscan object, fast-track it to black
ROUTINE ======================== runtime.growslice in /opt/go1.12.4/src/runtime/slice.go
      50ms      260ms (flat, cum) 15.66% of Total
         .          .     71:// NOT to the new requested capacity.
         .          .     72:// This is for codegen convenience. The old slice's length is used immediately
         .          .     73:// to calculate where to write new values during an append.
         .          .     74:// TODO: When the old backend is gone, reconsider this decision.
         .          .     75:// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
      10ms       10ms     76:func growslice(et *_type, old slice, cap int) slice {
         .          .     77:	if raceenabled {
         .          .     78:		callerpc := getcallerpc()
         .          .     79:		racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))
         .          .     80:	}
         .          .     81:	if msanenabled {
         .          .     82:		msanread(old.array, uintptr(old.len*int(et.size)))
         .          .     83:	}
         .          .     84:
         .          .     85:	if cap < old.cap {
         .          .     86:		panic(errorString("growslice: cap out of range"))
         .          .     87:	}
         .          .     88:
         .          .     89:	if et.size == 0 {
         .          .     90:		// append should not create a slice with nil pointer but non-zero len.
         .          .     91:		// We assume that append doesn't need to preserve old.array in this case.
         .          .     92:		return slice{unsafe.Pointer(&zerobase), old.len, cap}
         .          .     93:	}
         .          .     94:
         .          .     95:	newcap := old.cap
         .          .     96:	doublecap := newcap + newcap
         .          .     97:	if cap > doublecap {
         .          .     98:		newcap = cap
         .          .     99:	} else {
         .          .    100:		if old.len < 1024 {
         .          .    101:			newcap = doublecap
         .          .    102:		} else {
         .          .    103:			// Check 0 < newcap to detect overflow
         .          .    104:			// and prevent an infinite loop.
         .          .    105:			for 0 < newcap && newcap < cap {
         .          .    106:				newcap += newcap / 4
         .          .    107:			}
         .          .    108:			// Set newcap to the requested cap when
         .          .    109:			// the newcap calculation overflowed.
         .          .    110:			if newcap <= 0 {
         .          .    111:				newcap = cap
         .          .    112:			}
         .          .    113:		}
         .          .    114:	}
         .          .    115:
         .          .    116:	var overflow bool
         .          .    117:	var lenmem, newlenmem, capmem uintptr
         .          .    118:	// Specialize for common values of et.size.
         .          .    119:	// For 1 we don't need any division/multiplication.
         .          .    120:	// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
         .          .    121:	// For powers of 2, use a variable shift.
         .          .    122:	switch {
         .          .    123:	case et.size == 1:
         .          .    124:		lenmem = uintptr(old.len)
         .          .    125:		newlenmem = uintptr(cap)
         .          .    126:		capmem = roundupsize(uintptr(newcap))
         .          .    127:		overflow = uintptr(newcap) > maxAlloc
         .          .    128:		newcap = int(capmem)
         .          .    129:	case et.size == sys.PtrSize:
         .          .    130:		lenmem = uintptr(old.len) * sys.PtrSize
         .          .    131:		newlenmem = uintptr(cap) * sys.PtrSize
         .          .    132:		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
      10ms       10ms    133:		overflow = uintptr(newcap) > maxAlloc/sys.PtrSize
         .          .    134:		newcap = int(capmem / sys.PtrSize)
         .          .    135:	case isPowerOfTwo(et.size):
         .          .    136:		var shift uintptr
         .          .    137:		if sys.PtrSize == 8 {
         .          .    138:			// Mask shift for better code generation.
         .          .    139:			shift = uintptr(sys.Ctz64(uint64(et.size))) & 63
         .          .    140:		} else {
         .          .    141:			shift = uintptr(sys.Ctz32(uint32(et.size))) & 31
         .          .    142:		}
         .          .    143:		lenmem = uintptr(old.len) << shift
         .          .    144:		newlenmem = uintptr(cap) << shift
         .          .    145:		capmem = roundupsize(uintptr(newcap) << shift)
         .          .    146:		overflow = uintptr(newcap) > (maxAlloc >> shift)
         .          .    147:		newcap = int(capmem >> shift)
         .          .    148:	default:
         .          .    149:		lenmem = uintptr(old.len) * et.size
         .          .    150:		newlenmem = uintptr(cap) * et.size
         .          .    151:		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
         .          .    152:		capmem = roundupsize(capmem)
         .          .    153:		newcap = int(capmem / et.size)
         .          .    154:	}
         .          .    155:
         .          .    156:	// The check of overflow in addition to capmem > maxAlloc is needed
         .          .    157:	// to prevent an overflow which can be used to trigger a segfault
         .          .    158:	// on 32bit architectures with this example program:
         .          .    159:	//
         .          .    160:	// type T [1<<27 + 1]int64
         .          .    161:	//
         .          .    162:	// var d T
         .          .    163:	// var s []T
         .          .    164:	//
         .          .    165:	// func main() {
         .          .    166:	//   s = append(s, d, d, d, d)
         .          .    167:	//   print(len(s), "\n")
         .          .    168:	// }
         .          .    169:	if overflow || capmem > maxAlloc {
         .          .    170:		panic(errorString("growslice: cap out of range"))
         .          .    171:	}
         .          .    172:
         .          .    173:	var p unsafe.Pointer
         .          .    174:	if et.kind&kindNoPointers != 0 {
         .      120ms    175:		p = mallocgc(capmem, nil, false)
         .          .    176:		// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
         .          .    177:		// Only clear the part that will not be overwritten.
      10ms       10ms    178:		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
         .          .    179:	} else {
         .          .    180:		// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
         .       70ms    181:		p = mallocgc(capmem, et, true)
         .          .    182:		if writeBarrier.enabled {
         .          .    183:			// Only shade the pointers in old.array since we know the destination slice p
         .          .    184:			// only contains nil pointers because it has been cleared during alloc.
         .          .    185:			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
         .          .    186:		}
         .          .    187:	}
      20ms       40ms    188:	memmove(p, old.array, lenmem)
         .          .    189:
         .          .    190:	return slice{p, old.len, newcap}
         .          .    191:}
         .          .    192:
         .          .    193:func isPowerOfTwo(x uintptr) bool {
ROUTINE ======================== runtime.heapBitsSetType in /opt/go1.12.4/src/runtime/mbitmap.go
      30ms       30ms (flat, cum)  1.81% of Total
         .          .   1103:	// This will have the effect of reading many bits out of b,
         .          .   1104:	// but once the real bits are shifted out, b will supply as many
         .          .   1105:	// zero bits as we try to read, which is exactly what we need.
         .          .   1106:
         .          .   1107:	p = ptrmask
      10ms       10ms   1108:	if typ.size < dataSize {
         .          .   1109:		// Filling in bits for an array of typ.
         .          .   1110:		// Set up for repetition of ptrmask during main loop.
         .          .   1111:		// Note that ptrmask describes only a prefix of
         .          .   1112:		const maxBits = sys.PtrSize*8 - 7
         .          .   1113:		if typ.ptrdata/sys.PtrSize <= maxBits {
         .          .   1114:			// Entire ptrmask fits in uintptr with room for a byte fragment.
         .          .   1115:			// Load into pbits and never read from ptrmask again.
         .          .   1116:			// This is especially important when the ptrmask has
         .          .   1117:			// fewer than 8 bits in it; otherwise the reload in the middle
         .          .   1118:			// of the Phase 2 loop would itself need to loop to gather
         .          .   1119:			// at least 8 bits.
         .          .   1120:
         .          .   1121:			// Accumulate ptrmask into b.
         .          .   1122:			// ptrmask is sized to describe only typ.ptrdata, but we record
         .          .   1123:			// it as describing typ.size bytes, since all the high bits are zero.
         .          .   1124:			nb = typ.ptrdata / sys.PtrSize
         .          .   1125:			for i := uintptr(0); i < nb; i += 8 {
         .          .   1126:				b |= uintptr(*p) << i
         .          .   1127:				p = add1(p)
         .          .   1128:			}
         .          .   1129:			nb = typ.size / sys.PtrSize
         .          .   1130:
         .          .   1131:			// Replicate ptrmask to fill entire pbits uintptr.
         .          .   1132:			// Doubling and truncating is fewer steps than
         .          .   1133:			// iterating by nb each time. (nb could be 1.)
         .          .   1134:			// Since we loaded typ.ptrdata/sys.PtrSize bits
         .          .   1135:			// but are pretending to have typ.size/sys.PtrSize,
         .          .   1136:			// there might be no replication necessary/possible.
         .          .   1137:			pbits = b
         .          .   1138:			endnb = nb
         .          .   1139:			if nb+nb <= maxBits {
         .          .   1140:				for endnb <= sys.PtrSize*8 {
         .          .   1141:					pbits |= pbits << endnb
         .          .   1142:					endnb += endnb
         .          .   1143:				}
         .          .   1144:				// Truncate to a multiple of original ptrmask.
         .          .   1145:				// Because nb+nb <= maxBits, nb fits in a byte.
         .          .   1146:				// Byte division is cheaper than uintptr division.
      10ms       10ms   1147:				endnb = uintptr(maxBits/byte(nb)) * nb
         .          .   1148:				pbits &= 1<<endnb - 1
         .          .   1149:				b = pbits
         .          .   1150:				nb = endnb
         .          .   1151:			}
         .          .   1152:
         .          .   1153:			// Clear p and endp as sentinel for using pbits.
         .          .   1154:			// Checked during Phase 2 loop.
         .          .   1155:			p = nil
         .          .   1156:			endp = nil
         .          .   1157:		} else {
         .          .   1158:			// Ptrmask is larger. Read it multiple times.
         .          .   1159:			n := (typ.ptrdata/sys.PtrSize+7)/8 - 1
         .          .   1160:			endp = addb(ptrmask, n)
         .          .   1161:			endnb = typ.size/sys.PtrSize - n*8
         .          .   1162:		}
         .          .   1163:	}
         .          .   1164:	if p != nil {
         .          .   1165:		b = uintptr(*p)
         .          .   1166:		p = add1(p)
         .          .   1167:		nb = 8
         .          .   1168:	}
         .          .   1169:
         .          .   1170:	if typ.size == dataSize {
         .          .   1171:		// Single entry: can stop once we reach the non-pointer data.
         .          .   1172:		nw = typ.ptrdata / sys.PtrSize
         .          .   1173:	} else {
         .          .   1174:		// Repeated instances of typ in an array.
         .          .   1175:		// Have to process first N-1 entries in full, but can stop
         .          .   1176:		// once we reach the non-pointer data in the final entry.
         .          .   1177:		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
         .          .   1178:	}
         .          .   1179:	if nw == 0 {
         .          .   1180:		// No pointers! Caller was supposed to check.
         .          .   1181:		println("runtime: invalid type ", typ.string())
         .          .   1182:		throw("heapBitsSetType: called with non-pointer type")
         .          .   1183:		return
         .          .   1184:	}
         .          .   1185:	if nw < 2 {
         .          .   1186:		// Must write at least 2 words, because the "no scan"
         .          .   1187:		// encoding doesn't take effect until the third word.
         .          .   1188:		nw = 2
         .          .   1189:	}
         .          .   1190:
         .          .   1191:	// Phase 1: Special case for leading byte (shift==0) or half-byte (shift==2).
         .          .   1192:	// The leading byte is special because it contains the bits for word 1,
         .          .   1193:	// which does not have the scan bit set.
         .          .   1194:	// The leading half-byte is special because it's a half a byte,
         .          .   1195:	// so we have to be careful with the bits already there.
         .          .   1196:	switch {
         .          .   1197:	default:
         .          .   1198:		throw("heapBitsSetType: unexpected shift")
         .          .   1199:
         .          .   1200:	case h.shift == 0:
         .          .   1201:		// Ptrmask and heap bitmap are aligned.
         .          .   1202:		// Handle first byte of bitmap specially.
         .          .   1203:		//
         .          .   1204:		// The first byte we write out covers the first four
         .          .   1205:		// words of the object. The scan/dead bit on the first
         .          .   1206:		// word must be set to scan since there are pointers
         .          .   1207:		// somewhere in the object. The scan/dead bit on the
         .          .   1208:		// second word is the checkmark, so we don't set it.
         .          .   1209:		// In all following words, we set the scan/dead
         .          .   1210:		// appropriately to indicate that the object contains
         .          .   1211:		// to the next 2-bit entry in the bitmap.
         .          .   1212:		//
         .          .   1213:		// TODO: It doesn't matter if we set the checkmark, so
         .          .   1214:		// maybe this case isn't needed any more.
         .          .   1215:		hb = b & bitPointerAll
         .          .   1216:		hb |= bitScan | bitScan<<(2*heapBitsShift) | bitScan<<(3*heapBitsShift)
         .          .   1217:		if w += 4; w >= nw {
         .          .   1218:			goto Phase3
         .          .   1219:		}
         .          .   1220:		*hbitp = uint8(hb)
         .          .   1221:		hbitp = add1(hbitp)
         .          .   1222:		b >>= 4
         .          .   1223:		nb -= 4
         .          .   1224:
         .          .   1225:	case sys.PtrSize == 8 && h.shift == 2:
         .          .   1226:		// Ptrmask and heap bitmap are misaligned.
         .          .   1227:		// The bits for the first two words are in a byte shared
         .          .   1228:		// with another object, so we must be careful with the bits
         .          .   1229:		// already there.
         .          .   1230:		// We took care of 1-word and 2-word objects above,
         .          .   1231:		// so this is at least a 6-word object.
         .          .   1232:		hb = (b & (bitPointer | bitPointer<<heapBitsShift)) << (2 * heapBitsShift)
         .          .   1233:		// This is not noscan, so set the scan bit in the
         .          .   1234:		// first word.
         .          .   1235:		hb |= bitScan << (2 * heapBitsShift)
         .          .   1236:		b >>= 2
         .          .   1237:		nb -= 2
         .          .   1238:		// Note: no bitScan for second word because that's
         .          .   1239:		// the checkmark.
         .          .   1240:		*hbitp &^= uint8((bitPointer | bitScan | (bitPointer << heapBitsShift)) << (2 * heapBitsShift))
         .          .   1241:		*hbitp |= uint8(hb)
         .          .   1242:		hbitp = add1(hbitp)
         .          .   1243:		if w += 2; w >= nw {
         .          .   1244:			// We know that there is more data, because we handled 2-word objects above.
         .          .   1245:			// This must be at least a 6-word object. If we're out of pointer words,
         .          .   1246:			// mark no scan in next bitmap byte and finish.
         .          .   1247:			hb = 0
         .          .   1248:			w += 4
         .          .   1249:			goto Phase3
         .          .   1250:		}
         .          .   1251:	}
         .          .   1252:
         .          .   1253:	// Phase 2: Full bytes in bitmap, up to but not including write to last byte (full or partial) in bitmap.
         .          .   1254:	// The loop computes the bits for that last write but does not execute the write;
         .          .   1255:	// it leaves the bits in hb for processing by phase 3.
         .          .   1256:	// To avoid repeated adjustment of nb, we subtract out the 4 bits we're going to
         .          .   1257:	// use in the first half of the loop right now, and then we only adjust nb explicitly
         .          .   1258:	// if the 8 bits used by each iteration isn't balanced by 8 bits loaded mid-loop.
         .          .   1259:	nb -= 4
         .          .   1260:	for {
         .          .   1261:		// Emit bitmap byte.
         .          .   1262:		// b has at least nb+4 bits, with one exception:
         .          .   1263:		// if w+4 >= nw, then b has only nw-w bits,
         .          .   1264:		// but we'll stop at the break and then truncate
         .          .   1265:		// appropriately in Phase 3.
         .          .   1266:		hb = b & bitPointerAll
         .          .   1267:		hb |= bitScanAll
         .          .   1268:		if w += 4; w >= nw {
         .          .   1269:			break
         .          .   1270:		}
         .          .   1271:		*hbitp = uint8(hb)
         .          .   1272:		hbitp = add1(hbitp)
         .          .   1273:		b >>= 4
         .          .   1274:
         .          .   1275:		// Load more bits. b has nb right now.
         .          .   1276:		if p != endp {
         .          .   1277:			// Fast path: keep reading from ptrmask.
         .          .   1278:			// nb unmodified: we just loaded 8 bits,
         .          .   1279:			// and the next iteration will consume 8 bits,
         .          .   1280:			// leaving us with the same nb the next time we're here.
         .          .   1281:			if nb < 8 {
         .          .   1282:				b |= uintptr(*p) << nb
         .          .   1283:				p = add1(p)
         .          .   1284:			} else {
         .          .   1285:				// Reduce the number of bits in b.
         .          .   1286:				// This is important if we skipped
         .          .   1287:				// over a scalar tail, since nb could
         .          .   1288:				// be larger than the bit width of b.
         .          .   1289:				nb -= 8
         .          .   1290:			}
         .          .   1291:		} else if p == nil {
         .          .   1292:			// Almost as fast path: track bit count and refill from pbits.
         .          .   1293:			// For short repetitions.
         .          .   1294:			if nb < 8 {
         .          .   1295:				b |= pbits << nb
         .          .   1296:				nb += endnb
         .          .   1297:			}
      10ms       10ms   1298:			nb -= 8 // for next iteration
         .          .   1299:		} else {
         .          .   1300:			// Slow path: reached end of ptrmask.
         .          .   1301:			// Process final partial byte and rewind to start.
         .          .   1302:			b |= uintptr(*p) << nb
         .          .   1303:			nb += endnb
ROUTINE ======================== runtime.lock in /opt/go1.12.4/src/runtime/lock_futex.go
         0       10ms (flat, cum)   0.6% of Total
         .          .     78:			for l.key == mutex_unlocked {
         .          .     79:				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
         .          .     80:					return
         .          .     81:				}
         .          .     82:			}
         .       10ms     83:			procyield(active_spin_cnt)
         .          .     84:		}
         .          .     85:
         .          .     86:		// Try for lock, rescheduling.
         .          .     87:		for i := 0; i < passive_spin; i++ {
         .          .     88:			for l.key == mutex_unlocked {
ROUTINE ======================== runtime.mProf_Malloc in /opt/go1.12.4/src/runtime/mprof.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    337:}
         .          .    338:
         .          .    339:// Called by malloc to record a profiled block.
         .          .    340:func mProf_Malloc(p unsafe.Pointer, size uintptr) {
         .          .    341:	var stk [maxStack]uintptr
         .       10ms    342:	nstk := callers(4, stk[:])
         .          .    343:	lock(&proflock)
         .          .    344:	b := stkbucket(memProfile, size, stk[:nstk], true)
         .          .    345:	c := mProf.cycle
         .          .    346:	mp := b.mp()
         .          .    347:	mpc := &mp.future[(c+2)%uint32(len(mp.future))]
ROUTINE ======================== runtime.makeslice in /opt/go1.12.4/src/runtime/slice.go
      20ms       20ms (flat, cum)  1.20% of Total
         .          .     29:
         .          .     30:func panicmakeslicecap() {
         .          .     31:	panic(errorString("makeslice: cap out of range"))
         .          .     32:}
         .          .     33:
      10ms       10ms     34:func makeslice(et *_type, len, cap int) unsafe.Pointer {
         .          .     35:	mem, overflow := math.MulUintptr(et.size, uintptr(cap))
         .          .     36:	if overflow || mem > maxAlloc || len < 0 || len > cap {
         .          .     37:		// NOTE: Produce a 'len out of range' error instead of a
         .          .     38:		// 'cap out of range' error when someone does make([]T, bignumber).
         .          .     39:		// 'cap out of range' is true too, but since the cap is only being
         .          .     40:		// supplied implicitly, saying len is clearer.
         .          .     41:		// See golang.org/issue/4085.
         .          .     42:		mem, overflow := math.MulUintptr(et.size, uintptr(len))
         .          .     43:		if overflow || mem > maxAlloc || len < 0 {
         .          .     44:			panicmakeslicelen()
         .          .     45:		}
         .          .     46:		panicmakeslicecap()
         .          .     47:	}
         .          .     48:
      10ms       10ms     49:	return mallocgc(mem, et, true)
         .          .     50:}
         .          .     51:
         .          .     52:func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {
         .          .     53:	len := int(len64)
         .          .     54:	if int64(len) != len64 {
ROUTINE ======================== runtime.mallocgc in /opt/go1.12.4/src/runtime/malloc.go
      70ms      190ms (flat, cum) 11.45% of Total
         .          .    832:		if assistG.m.curg != nil {
         .          .    833:			assistG = assistG.m.curg
         .          .    834:		}
         .          .    835:		// Charge the allocation against the G. We'll account
         .          .    836:		// for internal fragmentation at the end of mallocgc.
      10ms       10ms    837:		assistG.gcAssistBytes -= int64(size)
         .          .    838:
         .          .    839:		if assistG.gcAssistBytes < 0 {
         .          .    840:			// This G is in debt. Assist the GC to correct
         .          .    841:			// this before allocating. This must happen
         .          .    842:			// before disabling preemption.
         .       20ms    843:			gcAssistAlloc(assistG)
         .          .    844:		}
         .          .    845:	}
         .          .    846:
         .          .    847:	// Set mp.mallocing to keep from being preempted by GC.
         .          .    848:	mp := acquirem()
         .          .    849:	if mp.mallocing != 0 {
         .          .    850:		throw("malloc deadlock")
         .          .    851:	}
      10ms       10ms    852:	if mp.gsignal == getg() {
         .          .    853:		throw("malloc during signal")
         .          .    854:	}
         .          .    855:	mp.mallocing = 1
         .          .    856:
         .          .    857:	shouldhelpgc := false
         .          .    858:	dataSize := size
         .          .    859:	c := gomcache()
         .          .    860:	var x unsafe.Pointer
      10ms       10ms    861:	noscan := typ == nil || typ.kind&kindNoPointers != 0
         .          .    862:	if size <= maxSmallSize {
         .          .    863:		if noscan && size < maxTinySize {
         .          .    864:			// Tiny allocator.
         .          .    865:			//
         .          .    866:			// Tiny allocator combines several tiny allocation requests
         .          .    867:			// into a single memory block. The resulting memory block
         .          .    868:			// is freed when all subobjects are unreachable. The subobjects
         .          .    869:			// must be noscan (don't have pointers), this ensures that
         .          .    870:			// the amount of potentially wasted memory is bounded.
         .          .    871:			//
         .          .    872:			// Size of the memory block used for combining (maxTinySize) is tunable.
         .          .    873:			// Current setting is 16 bytes, which relates to 2x worst case memory
         .          .    874:			// wastage (when all but one subobjects are unreachable).
         .          .    875:			// 8 bytes would result in no wastage at all, but provides less
         .          .    876:			// opportunities for combining.
         .          .    877:			// 32 bytes provides more opportunities for combining,
         .          .    878:			// but can lead to 4x worst case wastage.
         .          .    879:			// The best case winning is 8x regardless of block size.
         .          .    880:			//
         .          .    881:			// Objects obtained from tiny allocator must not be freed explicitly.
         .          .    882:			// So when an object will be freed explicitly, we ensure that
         .          .    883:			// its size >= maxTinySize.
         .          .    884:			//
         .          .    885:			// SetFinalizer has a special case for objects potentially coming
         .          .    886:			// from tiny allocator, it such case it allows to set finalizers
         .          .    887:			// for an inner byte of a memory block.
         .          .    888:			//
         .          .    889:			// The main targets of tiny allocator are small strings and
         .          .    890:			// standalone escaping variables. On a json benchmark
         .          .    891:			// the allocator reduces number of allocations by ~12% and
         .          .    892:			// reduces heap size by ~20%.
         .          .    893:			off := c.tinyoffset
         .          .    894:			// Align tiny pointer for required (conservative) alignment.
         .          .    895:			if size&7 == 0 {
         .          .    896:				off = round(off, 8)
         .          .    897:			} else if size&3 == 0 {
         .          .    898:				off = round(off, 4)
         .          .    899:			} else if size&1 == 0 {
         .          .    900:				off = round(off, 2)
         .          .    901:			}
         .          .    902:			if off+size <= maxTinySize && c.tiny != 0 {
         .          .    903:				// The object fits into existing tiny block.
         .          .    904:				x = unsafe.Pointer(c.tiny + off)
         .          .    905:				c.tinyoffset = off + size
         .          .    906:				c.local_tinyallocs++
         .          .    907:				mp.mallocing = 0
         .          .    908:				releasem(mp)
         .          .    909:				return x
         .          .    910:			}
         .          .    911:			// Allocate a new maxTinySize block.
         .          .    912:			span := c.alloc[tinySpanClass]
         .          .    913:			v := nextFreeFast(span)
         .          .    914:			if v == 0 {
         .          .    915:				v, _, shouldhelpgc = c.nextFree(tinySpanClass)
         .          .    916:			}
         .          .    917:			x = unsafe.Pointer(v)
         .          .    918:			(*[2]uint64)(x)[0] = 0
         .          .    919:			(*[2]uint64)(x)[1] = 0
         .          .    920:			// See if we need to replace the existing tiny block with the new one
         .          .    921:			// based on amount of remaining free space.
         .          .    922:			if size < c.tinyoffset || c.tiny == 0 {
         .          .    923:				c.tiny = uintptr(x)
         .          .    924:				c.tinyoffset = size
         .          .    925:			}
         .          .    926:			size = maxTinySize
         .          .    927:		} else {
         .          .    928:			var sizeclass uint8
         .          .    929:			if size <= smallSizeMax-8 {
         .          .    930:				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
         .          .    931:			} else {
         .          .    932:				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
         .          .    933:			}
         .          .    934:			size = uintptr(class_to_size[sizeclass])
         .          .    935:			spc := makeSpanClass(sizeclass, noscan)
      10ms       10ms    936:			span := c.alloc[spc]
      20ms       50ms    937:			v := nextFreeFast(span)
         .          .    938:			if v == 0 {
         .       30ms    939:				v, span, shouldhelpgc = c.nextFree(spc)
         .          .    940:			}
         .          .    941:			x = unsafe.Pointer(v)
         .          .    942:			if needzero && span.needzero != 0 {
         .          .    943:				memclrNoHeapPointers(unsafe.Pointer(v), size)
         .          .    944:			}
         .          .    945:		}
         .          .    946:	} else {
         .          .    947:		var s *mspan
         .          .    948:		shouldhelpgc = true
         .          .    949:		systemstack(func() {
         .          .    950:			s = largeAlloc(size, needzero, noscan)
         .          .    951:		})
         .          .    952:		s.freeindex = 1
         .          .    953:		s.allocCount = 1
         .          .    954:		x = unsafe.Pointer(s.base())
         .          .    955:		size = s.elemsize
         .          .    956:	}
         .          .    957:
         .          .    958:	var scanSize uintptr
         .          .    959:	if !noscan {
         .          .    960:		// If allocating a defer+arg block, now that we've picked a malloc size
         .          .    961:		// large enough to hold everything, cut the "asked for" size down to
         .          .    962:		// just the defer header, so that the GC bitmap will record the arg block
         .          .    963:		// as containing nothing at all (as if it were unused space at the end of
         .          .    964:		// a malloc block caused by size rounding).
         .          .    965:		// The defer arg areas are scanned as part of scanstack.
         .          .    966:		if typ == deferType {
         .          .    967:			dataSize = unsafe.Sizeof(_defer{})
         .          .    968:		}
         .       30ms    969:		heapBitsSetType(uintptr(x), size, dataSize, typ)
         .          .    970:		if dataSize > typ.size {
         .          .    971:			// Array allocation. If there are any
         .          .    972:			// pointers, GC has to scan to the last
         .          .    973:			// element.
         .          .    974:			if typ.ptrdata != 0 {
         .          .    975:				scanSize = dataSize - typ.size + typ.ptrdata
         .          .    976:			}
         .          .    977:		} else {
         .          .    978:			scanSize = typ.ptrdata
         .          .    979:		}
         .          .    980:		c.local_scan += scanSize
         .          .    981:	}
         .          .    982:
         .          .    983:	// Ensure that the stores above that initialize x to
         .          .    984:	// type-safe memory and set the heap bits occur before
         .          .    985:	// the caller can make x observable to the garbage
         .          .    986:	// collector. Otherwise, on weakly ordered machines,
         .          .    987:	// the garbage collector could follow a pointer to x,
         .          .    988:	// but see uninitialized memory or stale heap bits.
         .          .    989:	publicationBarrier()
         .          .    990:
         .          .    991:	// Allocate black during GC.
         .          .    992:	// All slots hold nil so no scanning is needed.
         .          .    993:	// This may be racing with GC so do it atomically if there can be
         .          .    994:	// a race marking the bit.
         .          .    995:	if gcphase != _GCoff {
         .          .    996:		gcmarknewobject(uintptr(x), size, scanSize)
         .          .    997:	}
         .          .    998:
         .          .    999:	if raceenabled {
         .          .   1000:		racemalloc(x, size)
         .          .   1001:	}
         .          .   1002:
         .          .   1003:	if msanenabled {
         .          .   1004:		msanmalloc(x, size)
         .          .   1005:	}
         .          .   1006:
         .          .   1007:	mp.mallocing = 0
         .          .   1008:	releasem(mp)
         .          .   1009:
         .          .   1010:	if debug.allocfreetrace != 0 {
         .          .   1011:		tracealloc(x, size, typ)
         .          .   1012:	}
         .          .   1013:
         .          .   1014:	if rate := MemProfileRate; rate > 0 {
         .          .   1015:		if rate != 1 && int32(size) < c.next_sample {
         .          .   1016:			c.next_sample -= int32(size)
         .          .   1017:		} else {
         .          .   1018:			mp := acquirem()
         .       10ms   1019:			profilealloc(mp, x, size)
         .          .   1020:			releasem(mp)
         .          .   1021:		}
         .          .   1022:	}
         .          .   1023:
         .          .   1024:	if assistG != nil {
         .          .   1025:		// Account for internal fragmentation in the assist
         .          .   1026:		// debt now that we know it.
         .          .   1027:		assistG.gcAssistBytes -= int64(size - dataSize)
         .          .   1028:	}
         .          .   1029:
         .          .   1030:	if shouldhelpgc {
         .          .   1031:		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
         .          .   1032:			gcStart(t)
         .          .   1033:		}
         .          .   1034:	}
         .          .   1035:
      10ms       10ms   1036:	return x
         .          .   1037:}
         .          .   1038:
         .          .   1039:func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {
         .          .   1040:	// print("largeAlloc size=", size, "\n")
         .          .   1041:
ROUTINE ======================== runtime.memclrNoHeapPointers in /opt/go1.12.4/src/runtime/memclr_amd64.s
      30ms       30ms (flat, cum)  1.81% of Total
         .          .     20:	// BSR+branch table make almost all memmove/memclr benchmarks worse. Not worth doing.
         .          .     21:	TESTQ	BX, BX
         .          .     22:	JEQ	_0
         .          .     23:	CMPQ	BX, $2
         .          .     24:	JBE	_1or2
      10ms       10ms     25:	CMPQ	BX, $4
         .          .     26:	JBE	_3or4
         .          .     27:	CMPQ	BX, $8
         .          .     28:	JB	_5through7
         .          .     29:	JE	_8
         .          .     30:	CMPQ	BX, $16
         .          .     31:	JBE	_9through16
         .          .     32:	PXOR	X0, X0
         .          .     33:	CMPQ	BX, $32
         .          .     34:	JBE	_17through32
         .          .     35:	CMPQ	BX, $64
         .          .     36:	JBE	_33through64
         .          .     37:	CMPQ	BX, $128
         .          .     38:	JBE	_65through128
         .          .     39:	CMPQ	BX, $256
         .          .     40:	JBE	_129through256
         .          .     41:	CMPB	internal∕cpu·X86+const_offsetX86HasAVX2(SB), $1
         .          .     42:	JE loop_preheader_avx2
         .          .     43:	// TODO: for really big clears, use MOVNTDQ, even without AVX2.
         .          .     44:
         .          .     45:loop:
         .          .     46:	MOVOU	X0, 0(DI)
         .          .     47:	MOVOU	X0, 16(DI)
         .          .     48:	MOVOU	X0, 32(DI)
         .          .     49:	MOVOU	X0, 48(DI)
         .          .     50:	MOVOU	X0, 64(DI)
         .          .     51:	MOVOU	X0, 80(DI)
         .          .     52:	MOVOU	X0, 96(DI)
         .          .     53:	MOVOU	X0, 112(DI)
         .          .     54:	MOVOU	X0, 128(DI)
         .          .     55:	MOVOU	X0, 144(DI)
         .          .     56:	MOVOU	X0, 160(DI)
         .          .     57:	MOVOU	X0, 176(DI)
         .          .     58:	MOVOU	X0, 192(DI)
         .          .     59:	MOVOU	X0, 208(DI)
         .          .     60:	MOVOU	X0, 224(DI)
         .          .     61:	MOVOU	X0, 240(DI)
         .          .     62:	SUBQ	$256, BX
         .          .     63:	ADDQ	$256, DI
         .          .     64:	CMPQ	BX, $256
         .          .     65:	JAE	loop
         .          .     66:	JMP	tail
         .          .     67:
         .          .     68:loop_preheader_avx2:
      10ms       10ms     69:	VPXOR Y0, Y0, Y0
         .          .     70:	// For smaller sizes MOVNTDQ may be faster or slower depending on hardware.
         .          .     71:	// For larger sizes it is always faster, even on dual Xeons with 30M cache.
         .          .     72:	// TODO take into account actual LLC size. E. g. glibc uses LLC size/2.
         .          .     73:	CMPQ    BX, $0x2000000
         .          .     74:	JAE     loop_preheader_avx2_huge
         .          .     75:loop_avx2:
         .          .     76:	VMOVDQU	Y0, 0(DI)
         .          .     77:	VMOVDQU	Y0, 32(DI)
         .          .     78:	VMOVDQU	Y0, 64(DI)
         .          .     79:	VMOVDQU	Y0, 96(DI)
         .          .     80:	SUBQ	$128, BX
      10ms       10ms     81:	ADDQ	$128, DI
         .          .     82:	CMPQ	BX, $128
         .          .     83:	JAE	loop_avx2
         .          .     84:	VMOVDQU  Y0, -32(DI)(BX*1)
         .          .     85:	VMOVDQU  Y0, -64(DI)(BX*1)
         .          .     86:	VMOVDQU  Y0, -96(DI)(BX*1)
ROUTINE ======================== runtime.memequal in /opt/go1.12.4/src/internal/bytealg/equal_amd64.s
      10ms       10ms (flat, cum)   0.6% of Total
         .          .     23:	MOVB	$1, ret+48(FP)
         .          .     24:	RET
         .          .     25:
         .          .     26:// memequal(a, b unsafe.Pointer, size uintptr) bool
         .          .     27:TEXT runtime·memequal(SB),NOSPLIT,$0-25
      10ms       10ms     28:	MOVQ	a+0(FP), SI
         .          .     29:	MOVQ	b+8(FP), DI
         .          .     30:	CMPQ	SI, DI
         .          .     31:	JEQ	eq
         .          .     32:	MOVQ	size+16(FP), BX
         .          .     33:	LEAQ	ret+24(FP), AX
ROUTINE ======================== runtime.memmove in /opt/go1.12.4/src/runtime/memmove_amd64.s
      50ms       50ms (flat, cum)  3.01% of Total
         .          .     30:
         .          .     31:// func memmove(to, from unsafe.Pointer, n uintptr)
         .          .     32:TEXT runtime·memmove(SB), NOSPLIT, $0-24
         .          .     33:
         .          .     34:	MOVQ	to+0(FP), DI
      20ms       20ms     35:	MOVQ	from+8(FP), SI
         .          .     36:	MOVQ	n+16(FP), BX
         .          .     37:
         .          .     38:	// REP instructions have a high startup cost, so we handle small sizes
         .          .     39:	// with some straightline code. The REP MOVSQ instruction is really fast
         .          .     40:	// for large sizes. The cutover is approximately 2K.
         .          .     41:tail:
         .          .     42:	// move_129through256 or smaller work whether or not the source and the
         .          .     43:	// destination memory regions overlap because they load all data into
         .          .     44:	// registers before writing it back.  move_256through2048 on the other
         .          .     45:	// hand can be used only when the memory regions don't overlap or the copy
         .          .     46:	// direction is forward.
         .          .     47:	//
         .          .     48:	// BSR+branch table make almost all memmove/memclr benchmarks worse. Not worth doing.
         .          .     49:	TESTQ	BX, BX
         .          .     50:	JEQ	move_0
         .          .     51:	CMPQ	BX, $2
         .          .     52:	JBE	move_1or2
         .          .     53:	CMPQ	BX, $4
         .          .     54:	JB	move_3
         .          .     55:	JBE	move_4
         .          .     56:	CMPQ	BX, $8
         .          .     57:	JB	move_5through7
         .          .     58:	JE	move_8
         .          .     59:	CMPQ	BX, $16
         .          .     60:	JBE	move_9through16
         .          .     61:	CMPQ	BX, $32
         .          .     62:	JBE	move_17through32
         .          .     63:	CMPQ	BX, $64
         .          .     64:	JBE	move_33through64
         .          .     65:	CMPQ	BX, $128
         .          .     66:	JBE	move_65through128
         .          .     67:	CMPQ	BX, $256
         .          .     68:	JBE	move_129through256
         .          .     69:
         .          .     70:	TESTB	$1, runtime·useAVXmemmove(SB)
         .          .     71:	JNZ	avxUnaligned
         .          .     72:
         .          .     73:/*
         .          .     74: * check and set for backwards
         .          .     75: */
         .          .     76:	CMPQ	SI, DI
         .          .     77:	JLS	back
         .          .     78:
         .          .     79:/*
         .          .     80: * forward copy loop
         .          .     81: */
         .          .     82:forward:
         .          .     83:	CMPQ	BX, $2048
         .          .     84:	JLS	move_256through2048
         .          .     85:
         .          .     86:	// If REP MOVSB isn't fast, don't use it
         .          .     87:	CMPB	internal∕cpu·X86+const_offsetX86HasERMS(SB), $1 // enhanced REP MOVSB/STOSB
         .          .     88:	JNE	fwdBy8
         .          .     89:
         .          .     90:	// Check alignment
         .          .     91:	MOVL	SI, AX
         .          .     92:	ORL	DI, AX
         .          .     93:	TESTL	$7, AX
         .          .     94:	JEQ	fwdBy8
         .          .     95:
         .          .     96:	// Do 1 byte at a time
         .          .     97:	MOVQ	BX, CX
         .          .     98:	REP;	MOVSB
         .          .     99:	RET
         .          .    100:
         .          .    101:fwdBy8:
         .          .    102:	// Do 8 bytes at a time
         .          .    103:	MOVQ	BX, CX
         .          .    104:	SHRQ	$3, CX
         .          .    105:	ANDQ	$7, BX
         .          .    106:	REP;	MOVSQ
         .          .    107:	JMP	tail
         .          .    108:
         .          .    109:back:
         .          .    110:/*
         .          .    111: * check overlap
         .          .    112: */
         .          .    113:	MOVQ	SI, CX
         .          .    114:	ADDQ	BX, CX
         .          .    115:	CMPQ	CX, DI
         .          .    116:	JLS	forward
         .          .    117:/*
         .          .    118: * whole thing backwards has
         .          .    119: * adjusted addresses
         .          .    120: */
         .          .    121:	ADDQ	BX, DI
         .          .    122:	ADDQ	BX, SI
         .          .    123:	STD
         .          .    124:
         .          .    125:/*
         .          .    126: * copy
         .          .    127: */
         .          .    128:	MOVQ	BX, CX
         .          .    129:	SHRQ	$3, CX
         .          .    130:	ANDQ	$7, BX
         .          .    131:
         .          .    132:	SUBQ	$8, DI
         .          .    133:	SUBQ	$8, SI
         .          .    134:	REP;	MOVSQ
         .          .    135:
         .          .    136:	CLD
         .          .    137:	ADDQ	$8, DI
         .          .    138:	ADDQ	$8, SI
         .          .    139:	SUBQ	BX, DI
         .          .    140:	SUBQ	BX, SI
         .          .    141:	JMP	tail
         .          .    142:
         .          .    143:move_1or2:
         .          .    144:	MOVB	(SI), AX
         .          .    145:	MOVB	-1(SI)(BX*1), CX
         .          .    146:	MOVB	AX, (DI)
         .          .    147:	MOVB	CX, -1(DI)(BX*1)
         .          .    148:	RET
         .          .    149:move_0:
         .          .    150:	RET
         .          .    151:move_4:
         .          .    152:	MOVL	(SI), AX
         .          .    153:	MOVL	AX, (DI)
         .          .    154:	RET
         .          .    155:move_3:
         .          .    156:	MOVW	(SI), AX
         .          .    157:	MOVB	2(SI), CX
         .          .    158:	MOVW	AX, (DI)
         .          .    159:	MOVB	CX, 2(DI)
         .          .    160:	RET
         .          .    161:move_5through7:
         .          .    162:	MOVL	(SI), AX
         .          .    163:	MOVL	-4(SI)(BX*1), CX
         .          .    164:	MOVL	AX, (DI)
         .          .    165:	MOVL	CX, -4(DI)(BX*1)
         .          .    166:	RET
         .          .    167:move_8:
         .          .    168:	// We need a separate case for 8 to make sure we write pointers atomically.
         .          .    169:	MOVQ	(SI), AX
         .          .    170:	MOVQ	AX, (DI)
         .          .    171:	RET
         .          .    172:move_9through16:
         .          .    173:	MOVQ	(SI), AX
         .          .    174:	MOVQ	-8(SI)(BX*1), CX
         .          .    175:	MOVQ	AX, (DI)
      10ms       10ms    176:	MOVQ	CX, -8(DI)(BX*1)
      10ms       10ms    177:	RET
         .          .    178:move_17through32:
         .          .    179:	MOVOU	(SI), X0
         .          .    180:	MOVOU	-16(SI)(BX*1), X1
         .          .    181:	MOVOU	X0, (DI)
         .          .    182:	MOVOU	X1, -16(DI)(BX*1)
         .          .    183:	RET
         .          .    184:move_33through64:
         .          .    185:	MOVOU	(SI), X0
         .          .    186:	MOVOU	16(SI), X1
         .          .    187:	MOVOU	-32(SI)(BX*1), X2
         .          .    188:	MOVOU	-16(SI)(BX*1), X3
         .          .    189:	MOVOU	X0, (DI)
         .          .    190:	MOVOU	X1, 16(DI)
         .          .    191:	MOVOU	X2, -32(DI)(BX*1)
         .          .    192:	MOVOU	X3, -16(DI)(BX*1)
         .          .    193:	RET
         .          .    194:move_65through128:
         .          .    195:	MOVOU	(SI), X0
         .          .    196:	MOVOU	16(SI), X1
         .          .    197:	MOVOU	32(SI), X2
         .          .    198:	MOVOU	48(SI), X3
         .          .    199:	MOVOU	-64(SI)(BX*1), X4
         .          .    200:	MOVOU	-48(SI)(BX*1), X5
         .          .    201:	MOVOU	-32(SI)(BX*1), X6
         .          .    202:	MOVOU	-16(SI)(BX*1), X7
      10ms       10ms    203:	MOVOU	X0, (DI)
         .          .    204:	MOVOU	X1, 16(DI)
         .          .    205:	MOVOU	X2, 32(DI)
         .          .    206:	MOVOU	X3, 48(DI)
         .          .    207:	MOVOU	X4, -64(DI)(BX*1)
         .          .    208:	MOVOU	X5, -48(DI)(BX*1)
ROUTINE ======================== runtime.morestack in /opt/go1.12.4/src/runtime/asm_amd64.s
         0       10ms (flat, cum)   0.6% of Total
         .          .    424:
         .          .    425:	// Call newstack on m->g0's stack.
         .          .    426:	MOVQ	m_g0(BX), BX
         .          .    427:	MOVQ	BX, g(CX)
         .          .    428:	MOVQ	(g_sched+gobuf_sp)(BX), SP
         .       10ms    429:	CALL	runtime·newstack(SB)
         .          .    430:	CALL	runtime·abort(SB)	// crash if newstack returns
         .          .    431:	RET
         .          .    432:
         .          .    433:// morestack but not preserving ctxt.
         .          .    434:TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0
ROUTINE ======================== runtime.newMarkBits in /opt/go1.12.4/src/runtime/mheap.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1839:	blocksNeeded := uintptr((nelems + 63) / 64)
         .          .   1840:	bytesNeeded := blocksNeeded * 8
         .          .   1841:
         .          .   1842:	// Try directly allocating from the current head arena.
         .          .   1843:	head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&gcBitsArenas.next)))
         .       10ms   1844:	if p := head.tryAlloc(bytesNeeded); p != nil {
         .          .   1845:		return p
         .          .   1846:	}
         .          .   1847:
         .          .   1848:	// There's not enough room in the head arena. We may need to
         .          .   1849:	// allocate a new arena.
ROUTINE ======================== runtime.newstack in /opt/go1.12.4/src/runtime/stack.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1028:			gogo(&gp.sched) // never return
         .          .   1029:		}
         .          .   1030:
         .          .   1031:		// Act like goroutine called runtime.Gosched.
         .          .   1032:		casgstatus(gp, _Gwaiting, _Grunning)
         .       10ms   1033:		gopreempt_m(gp) // never return
         .          .   1034:	}
         .          .   1035:
         .          .   1036:	// Allocate a bigger segment and move the stack.
         .          .   1037:	oldsize := gp.stack.hi - gp.stack.lo
         .          .   1038:	newsize := oldsize * 2
ROUTINE ======================== runtime.nextFreeFast in /opt/go1.12.4/src/runtime/malloc.go
      30ms       30ms (flat, cum)  1.81% of Total
         .          .    748:// Otherwise it returns 0.
         .          .    749:func nextFreeFast(s *mspan) gclinkptr {
         .          .    750:	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
         .          .    751:	if theBit < 64 {
         .          .    752:		result := s.freeindex + uintptr(theBit)
      20ms       20ms    753:		if result < s.nelems {
      10ms       10ms    754:			freeidx := result + 1
         .          .    755:			if freeidx%64 == 0 && freeidx != s.nelems {
         .          .    756:				return 0
         .          .    757:			}
         .          .    758:			s.allocCache >>= uint(theBit + 1)
         .          .    759:			s.freeindex = freeidx
ROUTINE ======================== runtime.notewakeup in /opt/go1.12.4/src/runtime/lock_futex.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    131:	old := atomic.Xchg(key32(&n.key), 1)
         .          .    132:	if old != 0 {
         .          .    133:		print("notewakeup - double wakeup (", old, ")\n")
         .          .    134:		throw("notewakeup - double wakeup")
         .          .    135:	}
         .       10ms    136:	futexwakeup(key32(&n.key), 1)
         .          .    137:}
         .          .    138:
         .          .    139:func notesleep(n *note) {
         .          .    140:	gp := getg()
         .          .    141:	if gp != gp.m.g0 {
ROUTINE ======================== runtime.pageIndexOf in /opt/go1.12.4/src/runtime/mheap.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    765:
         .          .    766:// pageIndexOf returns the arena, page index, and page mask for pointer p.
         .          .    767:// The caller must ensure p is in the heap.
         .          .    768:func pageIndexOf(p uintptr) (arena *heapArena, pageIdx uintptr, pageMask uint8) {
         .          .    769:	ai := arenaIndex(p)
      10ms       10ms    770:	arena = mheap_.arenas[ai.l1()][ai.l2()]
         .          .    771:	pageIdx = ((p / pageSize) / 8) % uintptr(len(arena.pageInUse))
         .          .    772:	pageMask = byte(1 << ((p / pageSize) % 8))
         .          .    773:	return
         .          .    774:}
         .          .    775:
ROUTINE ======================== runtime.pcvalue in /opt/go1.12.4/src/runtime/symtab.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    652:	p := datap.pclntable[off:]
         .          .    653:	pc := f.entry
         .          .    654:	val := int32(-1)
         .          .    655:	for {
         .          .    656:		var ok bool
         .       10ms    657:		p, ok = step(p, &pc, &val, pc == f.entry)
         .          .    658:		if !ok {
         .          .    659:			break
         .          .    660:		}
         .          .    661:		if targetpc < pc {
         .          .    662:			// Replace a random entry in the cache. Random
ROUTINE ======================== runtime.procPin in /opt/go1.12.4/src/runtime/proc.go
      40ms       40ms (flat, cum)  2.41% of Total
         .          .   5067:	return false
         .          .   5068:}
         .          .   5069:
         .          .   5070://go:nosplit
         .          .   5071:func procPin() int {
      20ms       20ms   5072:	_g_ := getg()
         .          .   5073:	mp := _g_.m
         .          .   5074:
         .          .   5075:	mp.locks++
      20ms       20ms   5076:	return int(mp.p.ptr().id)
         .          .   5077:}
         .          .   5078:
         .          .   5079://go:nosplit
         .          .   5080:func procUnpin() {
         .          .   5081:	_g_ := getg()
ROUTINE ======================== runtime.procyield in /opt/go1.12.4/src/runtime/asm_amd64.s
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    545:
         .          .    546:TEXT runtime·procyield(SB),NOSPLIT,$0-0
         .          .    547:	MOVL	cycles+0(FP), AX
         .          .    548:again:
         .          .    549:	PAUSE
      10ms       10ms    550:	SUBL	$1, AX
         .          .    551:	JNZ	again
         .          .    552:	RET
         .          .    553:
         .          .    554:
         .          .    555:TEXT ·publicationBarrier(SB),NOSPLIT,$0-0
ROUTINE ======================== runtime.profilealloc in /opt/go1.12.4/src/runtime/malloc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1090:	return newarray(typ, n)
         .          .   1091:}
         .          .   1092:
         .          .   1093:func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
         .          .   1094:	mp.mcache.next_sample = nextSample()
         .       10ms   1095:	mProf_Malloc(x, size)
         .          .   1096:}
         .          .   1097:
         .          .   1098:// nextSample returns the next sampling point for heap profiling. The goal is
         .          .   1099:// to sample allocations on average every MemProfileRate bytes, but with a
         .          .   1100:// completely random distribution over the allocation timeline; this
ROUTINE ======================== runtime.readvarint in /opt/go1.12.4/src/runtime/symtab.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    816:	*pc += uintptr(pcdelta * sys.PCQuantum)
         .          .    817:	return p, true
         .          .    818:}
         .          .    819:
         .         .    820:// readvarint reads a varint from p.
      10ms       10ms    821:func readvarint(p []byte) (read uint32, val uint32) {
         .          .    822:	var v, shift, n uint32
         .          .    823:	for {
         .          .    824:		b := p[n]
         .          .    825:		n++
         .          .    826:		v |= uint32(b&0x7F) << (shift & 31)
ROUTINE ======================== runtime.runSafePointFn in /opt/go1.12.4/src/runtime/proc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   1436:	}
         .          .   1437:	sched.safePointFn(p)
         .          .   1438:	lock(&sched.lock)
         .          .   1439:	sched.safePointWait--
         .          .   1440:	if sched.safePointWait == 0 {
         .       10ms   1441:		notewakeup(&sched.safePointNote)
         .          .   1442:	}
         .          .   1443:	unlock(&sched.lock)
         .          .   1444:}
         .          .   1445:
         .          .   1446:// When running with cgo, we call _cgo_thread_start
ROUTINE ======================== runtime.scanobject in /opt/go1.12.4/src/runtime/mgcmark.go
      20ms       30ms (flat, cum)  1.81% of Total
         .          .   1134:			n = maxObletBytes
         .          .   1135:		}
         .          .   1136:	}
         .          .   1137:
         .          .   1138:	var i uintptr
      10ms       10ms   1139:	for i = 0; i < n; i += sys.PtrSize {
         .          .   1140:		// Find bits for this word.
         .          .   1141:		if i != 0 {
         .          .   1142:			// Avoid needless hbits.next() on last iteration.
         .          .   1143:			hbits = hbits.next()
         .          .   1144:		}
         .          .   1145:		// Load bits once. See CL 22712 and issue 16973 for discussion.
         .          .   1146:		bits := hbits.bits()
         .          .   1147:		// During checkmarking, 1-word objects store the checkmark
         .          .   1148:		// in the type bit for the one word. The only one-word objects
         .          .   1149:		// are pointers, or else they'd be merged with other non-pointer
         .          .   1150:		// data into larger allocations.
      10ms       10ms   1151:		if i != 1*sys.PtrSize && bits&bitScan == 0 {
         .          .   1152:			break // no more pointers in this object
         .          .   1153:		}
         .          .   1154:		if bits&bitPointer == 0 {
         .          .   1155:			continue // not a pointer
         .          .   1156:		}
         .          .   1157:
         .          .   1158:		// Work here is duplicated in scanblock and above.
         .          .   1159:		// If you make changes here, make changes there too.
         .          .   1160:		obj := *(*uintptr)(unsafe.Pointer(b + i))
         .          .   1161:
         .          .   1162:		// At this point we have extracted the next potential pointer.
         .          .   1163:		// Quickly filter out nil and pointers back to the current object.
         .          .   1164:		if obj != 0 && obj-b >= n {
         .          .   1165:			// Test if obj points into the Go heap and, if so,
         .          .   1166:			// mark the object.
         .          .   1167:			//
         .          .   1168:			// Note that it's possible for findObject to
         .          .   1169:			// fail if obj points to a just-allocated heap
         .          .   1170:			// object because of a race with growing the
         .          .   1171:			// heap. In this case, we know the object was
         .          .   1172:			// just allocated and hence will be marked by
         .          .   1173:			// allocation itself.
         .          .   1174:			if obj, span, objIndex := findObject(obj, b, i); obj != 0 {
         .       10ms   1175:				greyobject(obj, b, i, span, gcw, objIndex)
         .          .   1176:			}
         .          .   1177:		}
         .          .   1178:	}
         .          .   1179:	gcw.bytesMarked += uint64(n)
         .          .   1180:	gcw.scanWork += int64(i)
ROUTINE ======================== runtime.schedule in /opt/go1.12.4/src/runtime/proc.go
         0       10ms (flat, cum)   0.6% of Total
         .          .   2488:	if sched.gcwaiting != 0 {
         .          .   2489:		gcstopm()
         .          .   2490:		goto top
         .          .   2491:	}
         .          .   2492:	if _g_.m.p.ptr().runSafePointFn != 0 {
         .       10ms   2493:		runSafePointFn()
         .          .   2494:	}
         .          .   2495:
         .          .   2496:	var gp *g
         .          .   2497:	var inheritTime bool
         .          .   2498:	if trace.enabled || trace.shutdown {
ROUTINE ======================== runtime.step in /opt/go1.12.4/src/runtime/symtab.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    808:	p = p[n:]
         .          .    809:
         .          .    810:	pcdelta := uint32(p[0])
         .          .    811:	n = 1
         .          .    812:	if pcdelta&0x80 != 0 {
         .       10ms    813:		n, pcdelta = readvarint(p)
         .          .    814:	}
         .          .    815:	p = p[n:]
         .          .    816:	*pc += uintptr(pcdelta * sys.PCQuantum)
         .          .    817:	return p, true
         .          .    818:}
ROUTINE ======================== runtime.sweepone in /opt/go1.12.4/src/runtime/mgcsweep.go
         0       10ms (flat, cum)   0.6% of Total
         .          .    131:
         .          .    132:	// Sweep the span we found.
         .          .    133:	npages := ^uintptr(0)
         .          .    134:	if s != nil {
         .          .    135:		npages = s.npages
         .       10ms    136:		if s.sweep(false) {
         .          .    137:			// Whole span was freed. Count it toward the
         .          .    138:			// page reclaimer credit since these pages can
         .          .    139:			// now be used for span allocation.
         .          .    140:			atomic.Xadduintptr(&mheap_.reclaimCredit, npages)
         .          .    141:		} else {
ROUTINE ======================== runtime.systemstack in /opt/go1.12.4/src/runtime/asm_amd64.s
         0       70ms (flat, cum)  4.22% of Total
         .          .    346:	MOVQ	BX, SP
         .          .    347:
         .          .    348:	// call target function
         .          .    349:	MOVQ	DI, DX
         .          .    350:	MOVQ	0(DI), DI
         .       70ms    351:	CALL	DI
         .          .    352:
         .          .    353:	// switch back to g
         .          .    354:	get_tls(CX)
         .          .    355:	MOVQ	g(CX), AX
         .          .    356:	MOVQ	g_m(AX), BX
ROUTINE ======================== runtime.wbBufFlush in /opt/go1.12.4/src/runtime/mwbbuf.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    201:		}
         .          .    202:	}
         .          .    203:
         .          .    204:	// Switch to the system stack so we don't have to worry about
         .          .    205:	// the untyped stack slots or safe points.
         .       20ms    206:	systemstack(func() {
         .          .    207:		if debugCachedWork {
         .          .    208:			// For debugging, include the old value of the
         .          .    209:			// slot and some other data in the traceback.
         .          .    210:			wbBuf := &getg().m.p.ptr().wbBuf
         .          .    211:			var old uintptr
ROUTINE ======================== runtime.wbBufFlush.func1 in /opt/go1.12.4/src/runtime/mwbbuf.go
         0       20ms (flat, cum)  1.20% of Total
         .          .    213:				// dst may be nil in direct calls to wbBufFlush.
         .          .    214:				old = *dst
         .          .    215:			}
         .          .    216:			wbBufFlush1Debug(old, wbBuf.buf[0], wbBuf.buf[1], &wbBuf.buf[0], wbBuf.next)
         .          .    217:		} else {
         .       20ms    218:			wbBufFlush1(getg().m.p.ptr())
         .          .    219:		}
         .          .    220:	})
         .          .    221:}
         .          .    222:
         .          .    223:// wbBufFlush1Debug is a temporary function for debugging issue
ROUTINE ======================== runtime.wbBufFlush1 in /opt/go1.12.4/src/runtime/mwbbuf.go
      10ms       20ms (flat, cum)  1.20% of Total
         .          .    283:			//
         .          .    284:			// TODO: Should we filter out nils in the fast
         .          .    285:			// path to reduce the rate of flushes?
         .          .    286:			continue
         .          .    287:		}
      10ms       20ms    288:		obj, span, objIndex := findObject(ptr, 0, 0)
         .          .    289:		if obj == 0 {
         .          .    290:			continue
         .          .    291:		}
         .          .    292:		// TODO: Consider making two passes where the first
         .          .    293:		// just prefetches the mark bits.
ROUTINE ======================== strings.(*Builder).Grow in /opt/go1.12.4/src/strings/builder.go
         0       20ms (flat, cum)  1.20% of Total
         .          .     76:	b.copyCheck()
         .          .     77:	if n < 0 {
         .          .     78:		panic("strings.Builder.Grow: negative count")
         .          .     79:	}
         .          .     80:	if cap(b.buf)-len(b.buf) < n {
         .       20ms     81:		b.grow(n)
         .          .     82:	}
         .          .     83:}
         .          .     84:
         .          .     85:// Write appends the contents of p to b's buffer.
         .          .     86:// Write always returns len(p), nil.
ROUTINE ======================== strings.(*Builder).grow in /opt/go1.12.4/src/strings/builder.go
      10ms       20ms (flat, cum)  1.20% of Total
         .          .     62:}
         .          .     63:
         .          .     64:// grow copies the buffer to a new, larger buffer so that there are at least n
         .          .     65:// bytes of capacity beyond len(b.buf).
         .          .     66:func (b *Builder) grow(n int) {
      10ms       20ms     67:	buf := make([]byte, len(b.buf), 2*cap(b.buf)+n)
         .          .     68:	copy(buf, b.buf)
         .          .     69:	b.buf = buf
         .          .     70:}
         .          .     71:
         .          .     72:// Grow grows b's capacity, if necessary, to guarantee space for
ROUTINE ======================== strings.HasSuffix in /opt/go1.12.4/src/strings/strings.go
      70ms      100ms (flat, cum)  6.02% of Total
         .          .    449:	return len(s) >= len(prefix) && s[0:len(prefix)] == prefix
         .          .    450:}
         .          .    451:
         .          .    452:// HasSuffix tests whether the string s ends with suffix.
         .          .    453:func HasSuffix(s, suffix string) bool {
      70ms      100ms    454:	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
         .          .    455:}
         .          .    456:
         .          .    457:// Map returns a copy of the string s with all its characters modified
         .          .    458:// according to the mapping function. If mapping returns a negative value, the character is
         .          .    459:// dropped from the string with no replacement.
ROUTINE ======================== strings.ToLower in /opt/go1.12.4/src/strings/strings.go
      40ms       60ms (flat, cum)  3.61% of Total
         .          .    587:		c := s[i]
         .          .    588:		if c >= utf8.RuneSelf {
         .          .    589:			isASCII = false
         .          .    590:			break
         .          .    591:		}
      20ms       20ms    592:		hasUpper = hasUpper || (c >= 'A' && c <= 'Z')
         .          .    593:	}
         .          .    594:
         .          .    595:	if isASCII { // optimize for ASCII-only strings.
      10ms       10ms    596:		if !hasUpper {
         .          .    597:			return s
         .          .    598:		}
         .          .    599:		var b Builder
         .       20ms    600:		b.Grow(len(s))
      10ms       10ms    601:		for i := 0; i < len(s); i++ {
         .          .    602:			c := s[i]
         .          .    603:			if c >= 'A' && c <= 'Z' {
         .          .    604:				c += 'a' - 'A'
         .          .    605:			}
         .          .    606:			b.WriteByte(c)
ROUTINE ======================== sync.(*Pool).Get in /opt/go1.12.4/src/sync/pool.go
      10ms       40ms (flat, cum)  2.41% of Total
         .          .    123:// the result of calling p.New.
         .          .    124:func (p *Pool) Get() interface{} {
         .          .    125:	if race.Enabled {
         .          .    126:		race.Disable()
         .          .    127:	}
         .       30ms    128:	l := p.pin()
      10ms       10ms    129:	x := l.private
         .          .    130:	l.private = nil
         .          .    131:	runtime_procUnpin()
         .          .    132:	if x == nil {
         .          .    133:		l.Lock()
         .          .    134:		last := len(l.shared) - 1
ROUTINE ======================== sync.(*Pool).Put in /opt/go1.12.4/src/sync/pool.go
      30ms      110ms (flat, cum)  6.63% of Total
         .          .     83:	h := uint32((uint64(uint32(ptr)) * 0x85ebca6b) >> 16)
         .          .     84:	return unsafe.Pointer(&poolRaceHash[h%uint32(len(poolRaceHash))])
         .          .     85:}
         .          .     86:
         .          .     87:// Put adds x to the pool.
      10ms       10ms     88:func (p *Pool) Put(x interface{}) {
         .          .     89:	if x == nil {
         .          .     90:		return
         .          .     91:	}
         .          .     92:	if race.Enabled {
         .          .     93:		if fastrand()%4 == 0 {
         .          .     94:			// Randomly drop x on floor.
         .          .     95:			return
         .          .     96:		}
         .          .     97:		race.ReleaseMerge(poolRaceAddr(x))
         .          .     98:		race.Disable()
         .          .     99:	}
         .       70ms    100:	l := p.pin()
      20ms       20ms    101:	if l.private == nil {
         .          .    102:		l.private = x
         .          .    103:		x = nil
         .          .    104:	}
         .       10ms    105:	runtime_procUnpin()
         .          .    106:	if x != nil {
         .          .    107:		l.Lock()
         .          .    108:		l.shared = append(l.shared, x)
         .          .    109:		l.Unlock()
         .          .    110:	}
ROUTINE ======================== sync.(*Pool).pin in /opt/go1.12.4/src/sync/pool.go
      30ms      100ms (flat, cum)  6.02% of Total
         .          .    175:	return x
         .          .    176:}
         .          .    177:
         .          .    178:// pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P.
         .          .    179:// Caller must call runtime_procUnpin() when done with the pool.
      10ms       10ms    180:func (p *Pool) pin() *poolLocal {
      10ms       70ms    181:	pid := runtime_procPin()
         .          .    182:	// In pinSlow we store to localSize and then to local, here we load in opposite order.
         .          .    183:	// Since we've disabled preemption, GC cannot happen in between.
         .          .    184:	// Thus here we must observe local at least as large localSize.
         .          .    185:	// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).
         .          .    186:	s := atomic.LoadUintptr(&p.localSize) // load-acquire
         .          .    187:	l := p.local                          // load-consume
      10ms       10ms    188:	if uintptr(pid) < s {
         .       10ms    189:		return indexLocal(l, pid)
         .          .    190:	}
         .          .    191:	return p.pinSlow()
         .          .    192:}
         .          .    193:
         .          .    194:func (p *Pool) pinSlow() *poolLocal {
ROUTINE ======================== sync.indexLocal in /opt/go1.12.4/src/sync/pool.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .    246:func init() {
         .          .    247:	runtime_registerPoolCleanup(poolCleanup)
         .          .    248:}
         .          .    249:
         .          .    250:func indexLocal(l unsafe.Pointer, i int) *poolLocal {
      10ms       10ms    251:	lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{}))
         .          .    252:	return (*poolLocal)(lp)
         .          .    253:}
         .          .    254:
         .          .    255:// Implemented in runtime.
         .          .    256:func runtime_registerPoolCleanup(cleanup func())
ROUTINE ======================== sync.runtime_procPin in /opt/go1.12.4/src/runtime/proc.go
      20ms       60ms (flat, cum)  3.61% of Total
         .          .   5083:}
         .          .   5084:
         .          .   5085://go:linkname sync_runtime_procPin sync.runtime_procPin
         .          .   5086://go:nosplit
         .          .   5087:func sync_runtime_procPin() int {
      20ms       60ms   5088:	return procPin()
         .          .   5089:}
         .          .   5090:
         .          .   5091://go:linkname sync_runtime_procUnpin sync.runtime_procUnpin
         .          .   5092://go:nosplit
         .          .   5093:func sync_runtime_procUnpin() {
ROUTINE ======================== sync.runtime_procUnpin in /opt/go1.12.4/src/runtime/proc.go
      10ms       10ms (flat, cum)   0.6% of Total
         .          .   5089:}
         .          .   5090:
         .          .   5091://go:linkname sync_runtime_procUnpin sync.runtime_procUnpin
         .          .   5092://go:nosplit
         .          .   5093:func sync_runtime_procUnpin() {
      10ms       10ms   5094:	procUnpin()
         .          .   5095:}
         .          .   5096:
         .          .   5097://go:linkname sync_atomic_runtime_procPin sync/atomic.runtime_procPin
         .          .   5098://go:nosplit
         .          .   5099:func sync_atomic_runtime_procPin() int {
ROUTINE ======================== testing.(*B).launch in /opt/go1.12.4/src/testing/benchmark.go
         0      1.63s (flat, cum) 98.19% of Total
         .          .    323:			// Don't grow too fast in case we had timing errors previously.
         .          .    324:			// Be sure to run at least one more than last time.
         .          .    325:			n = max(min(n+n/5, 100*last), last+1)
         .          .    326:			// Round up to something easy to read.
         .          .    327:			n = roundUp(n)
         .      1.63s    328:			b.runN(n)
         .          .    329:		}
         .          .    330:	}
         .          .    331:	b.result = BenchmarkResult{b.N, b.duration, b.bytes, b.netAllocs, b.netBytes}
         .          .    332:}
         .          .    333:
ROUTINE ======================== testing.(*B).runN in /opt/go1.12.4/src/testing/benchmark.go
         0      1.63s (flat, cum) 98.19% of Total
         .          .    171:	b.raceErrors = -race.Errors()
         .          .    172:	b.N = n
         .          .    173:	b.parallelism = 1
         .          .    174:	b.ResetTimer()
         .          .    175:	b.StartTimer()
         .      1.63s    176:	b.benchFunc(b)
         .          .    177:	b.StopTimer()
         .          .    178:	b.previousN = n
         .          .    179:	b.previousDuration = b.duration
         .          .    180:	b.raceErrors += race.Errors()
         .          .    181:	if b.raceErrors > 0 {
(pprof)list nlp
Total: 1.66s
ROUTINE ======================== github.com/tebeka/nlp.BenchmarkTokenize in /home/miki/Teaching/the-daily-go/nlp/nlp_test.go
         0      1.63s (flat, cum) 98.19% of Total
         .          .     55:    - Russ Cox
         .          .     56:`
         .          .     57:
         .          .     58:func BenchmarkTokenize(b *testing.B) {
         .          .     59:	for i := 0; i < b.N; i++ {
         .      1.63s     60:		toks := Tokenize(tokBenchText)
         .          .     61:		if len(toks) != 16 {
         .          .     62:			b.Fatal(toks)
         .          .     63:		}
         .          .     64:	}
         .          .     65:}
ROUTINE ======================== github.com/tebeka/nlp.Tokenize in /home/miki/Teaching/the-daily-go/nlp/nlp.go
      10ms      1.63s (flat, cum) 98.19% of Total
         .          .     11:	wordRe = regexp.MustCompile("[[:alpha:]]+")
         .          .     12:)
         .          .     13:
         .          .     14:// Tokenize returns a slice of tokens found in text
         .          .     15:func Tokenize(text string) []string {
         .      1.39s     16:	words := wordRe.FindAllString(text, -1)
         .          .     17:	var tokens []string
         .          .     18:	for _, w := range words {
         .          .     19:		// TODO: stem
      10ms      170ms     20:		token := stemmer.Stem(strings.ToLower(w))
         .          .     21:		if token != "" {
         .       70ms     22:			tokens = append(tokens, token)
         .          .     23:		}
         .          .     24:	}
         .          .     25:	return tokens
         .          .     26:}
ROUTINE ======================== github.com/tebeka/nlp/stemmer.Stem in /home/miki/Teaching/the-daily-go/nlp/stemmer/stemmer.go
         0      100ms (flat, cum)  6.02% of Total
         .          .      9:)
         .          .     10:
         .          .     11:// Stem returns the stemmed version of word
         .          .     12:func Stem(word string) string {
         .          .     13:	for _, suffix := range suffixes {
         .      100ms     14:		if strings.HasSuffix(word, suffix) {
         .          .     15:			return word[:len(word)-len(suffix)]
         .          .     16:		}
         .          .     17:	}
         .          .     18:	return word
         .          .     19:}
(pprof)
(pprof) web
[20159:20177:0428/160925.176420:ERROR:browser_process_sub_thread.cc(217)] Waited 10 ms for network service
(pprof) web list
Focus expression matched no samples
[20239:20257:0428/161004.772312:ERROR:browser_process_sub_thread.cc(217)] Waited 23 ms for network service
(pprof) help web
Visualize graph through web browser
  Usage:
    web [n] [focus_regex]* [-ignore_regex]*
    Include up to n samples
    Include samples matching focus_regex, and exclude ignore_regex.

(pprof) help list
Output annotated source for functions matching regexp
  Usage:
    list<func_regex|address> [-focus_regex]* [-ignore_regex]*
    Include functions matching func_regex, or including the address specified.
    Include samples matching focus_regex, and exclude ignore_regex.

(pprof) help    
  Commands:
    callgrind        Outputs a graph in callgrind format
    comments         Output all profile comments
    disasm           Output assembly listings annotated with samples
    dot              Outputs a graph in DOT format
    eog              Visualize graph through eog
    evince           Visualize graph through evince
    gif              Outputs a graph image in GIF format
    gv               Visualize graph through gv
    kcachegrind      Visualize report in KCachegrind
    list             Output annotated source for functions matching regexp
    pdf              Outputs a graph in PDF format
    peek             Output callers/callees of functions matching regexp
    png              Outputs a graph image in PNG format
    proto            Outputs the profile in compressed protobuf format
    ps               Outputs a graph in PS format
    raw              Outputs a text representation of the raw profile
    svg              Outputs a graph in SVG format
    tags             Outputs all tags in the profile
    text             Outputs top entries in text form
    top              Outputs top entries in text form
    topproto         Outputs top entries in compressed protobuf format
    traces           Outputs all profile samples in text form
    tree             Outputs a text rendering of call graph
    web              Visualize graph through web browser
    weblist          Display annotated source in a web browser
    o/options        List options and their current values
    quit/exit/^D     Exit pprof

  Options:
    call_tree        Create a context-sensitive call tree
    compact_labels   Show minimal headers
    divide_by        Ratio to divide all samples before visualization
    drop_negative    Ignore negative differences
    edgefraction     Hide edges below <f>*total
    focus            Restricts to samples going through a node matching regexp
    hide             Skips nodes matching regexp
    ignore           Skips paths going through any nodes matching regexp
    mean             Average sample value over first value (count)
    nodecount        Max number of nodes to show
    nodefraction     Hide nodes below <f>*total
    noinlines        Ignore inlines.
    normalize        Scales profile based on the base profile.
    output           Output filename for file-based outputs
    prune_from       Drops any functions below the matched frame.
    relative_percentages Show percentages relative to focused subgraph
    sample_index     Sample value to report (0-based index or name)
    show             Only show nodes matching regexp
    show_from        Drops functions above the highest matched frame.
    source_path      Search path for source files
    tagfocus         Restricts to samples with tags in range or matched by regexp
    taghide          Skip tags matching this regexp
    tagignore        Discard samples with tags in range or matched by regexp
    tagshow          Only consider tags matching this regexp
    trim             Honor nodefraction/edgefraction/nodecount defaults
    trim_path        Path to trim from source paths before search
    unit             Measurement units to display

  Option groups (only set one per group):
    cumulative       
      cum              Sort entries based on cumulative weight
      flat             Sort entries based on own weight
    granularity      
      addresses        Aggregate at the address level.
      filefunctions    Aggregate at the function level.
      files            Aggregate at the file level.
      functions        Aggregate at the function level.
      lines            Aggregate at the source code line level.
  :   Clear focus/ignore/hide/tagfocus/tagignore

  type "help <cmd|option>" for more information
(pprof)weblist
command weblist requires an argument
(pprof) weblist nlp
open /tmp/go-build964677140/b001/nlp.test: no such file or directory
[20323:20341:0428/161103.340524:ERROR:browser_process_sub_thread.cc(217)] Waited 4 ms for network service
(pprof) top 20
Showing nodes accounting for 1430ms, 86.14% of 1660ms total
Showing top 20 nodes out of 88
      flat  flat%   sum%        cum   cum%
     260ms 15.66% 15.66%      700ms 42.17%  regexp.(*Regexp).tryBacktrack
     160ms  9.64% 25.30%      160ms  9.64%  regexp.(*bitState).shouldVisit
     110ms  6.63% 31.93%      140ms  8.43%  regexp.(*bitState).push
     100ms  6.02% 37.95%     1180ms 71.08%  regexp.(*Regexp).backtrack
     100ms  6.02% 43.98%      100ms  6.02%  regexp/syntax.(*Inst).MatchRunePos
      70ms  4.22% 48.19%      130ms  7.83%  regexp.(*Regexp).FindAllString.func1
      70ms  4.22% 52.41%     1390ms 83.73%  regexp.(*Regexp).allMatches
      70ms  4.22% 56.63%       70ms  4.22%  regexp.(*inputString).step
      70ms  4.22% 60.84%      190ms 11.45%  runtime.mallocgc
      70ms  4.22% 65.06%      100ms  6.02%  strings.HasSuffix
      50ms  3.01% 68.07%      260ms 15.66%  runtime.growslice
      50ms  3.01% 71.08%       50ms  3.01%  runtime.memmove
      40ms  2.41% 73.49%       40ms  2.41%  runtime.procPin
      40ms  2.41% 75.90%       60ms  3.61%  strings.ToLower
      30ms  1.81% 77.71%       30ms  1.81%  runtime.heapBitsSetType
      30ms  1.81% 79.52%       30ms  1.81%  runtime.memclrNoHeapPointers
      30ms  1.81% 81.33%       30ms  1.81%  runtime.nextFreeFast
      30ms  1.81% 83.13%      110ms  6.63%  sync.(*Pool).Put
      30ms  1.81% 84.94%      100ms  6.02%  sync.(*Pool).pin
      20ms  1.20% 86.14%       20ms  1.20%  memeqbody
(pprof)q
Unrecognized command: "q"
(pprof) quit
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                                                                   Sun Apr 28, 16:12 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      5059 ns/op
PASS
ok  	github.com/tebeka/nlp	1.578s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                                                                   Sun Apr 28, 16:12 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      4938 ns/op
PASS
ok  	github.com/tebeka/nlp	1.539s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                                                                   Sun Apr 28, 16:13 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      4808 ns/op
PASS
ok  	github.com/tebeka/nlp	1.499s╭─miki@saitama  nlp (git:master) 
╰─$ echo Back 4:30                                                                                  Sun Apr 28, 16:13 
Back 4:30
╭─miki@saitama  nlp (git:master) 
╰─$ git status -u                                                                                   Sun Apr 28, 16:18 
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   nlp.go
	modified:   nlp_test.go

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	nlp.test
	prof.out

no changes added to commit (use "git add" and/or "git commit -a")
╭─miki@saitama  nlp (git:master) 
╰─$ git add nlp.go nlp_test.go                                                                      Sun Apr 28, 16:19 
╭─miki@saitama  nlp (git:master) 
╰─$git commit -m 'small speed optimization'                                                        Sun Apr 28, 16:19 
[master 8484a7f] small speed optimization
 2 files changed, 16 insertions(+), 1 deletion(-)
╭─miki@saitama  nlp (git:master) 
╰─$ cat > .gitignore                                                                                Sun Apr 28, 16:19 
nlp.test
prof.out
╭─miki@saitama  nlp (git:master) 
╰─$ git add .gitignore                                                                              Sun Apr 28, 16:19 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'ignore'                                                                          Sun Apr 28, 16:19 
[master 36ab637] ignore
 1 file changed, 2 insertions(+)
 create mode 100644 .gitignore
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 16:19 
Enumerating objects: 10, done.
Counting objects: 100% (10/10), done.
Delta compression using up to 4 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (7/7), 965 bytes | 482.00 KiB/s, done.
Total 7 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 2 local objects.
To github.com:tebeka/nlp.git
   51a140e..36ab637  master -> master╭─miki@saitama  nlp (git:master) 
╰─$ mkdir cmd/nlpd                                                                                  Sun Apr 28, 16:19 
mkdir: cannot create directory ‘cmd/nlpd’: No such file or directory
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir cmd/nlpd                                                                               Sun Apr 28, 16:36 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ ls                                                                                         Sun Apr 28, 16:36 130 ↵
example_test.go  go.mod  go.sum  nlp.go  nlp.test  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir -p cmd/nlpd                                                                               Sun Apr 28, 16:36 
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                            Sun Apr 28, 16:36 
.
├── cmd
│   └── nlpd
│       └── nlpd.go
├── example_test.go
├── go.mod
├── go.sum
├── nlp.go
├── nlp.test
├── nlp_test.go
├── prof.out
└── stemmer
    ├── stemmer.go
    └── stemmer_test.go

3 directories, 10 files╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                               Sun Apr 28, 16:36 
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ git add cmd/nlpd/nlpd.go                                                                     Sun Apr 28, 16:56 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'http server'                                                                     Sun Apr 28, 16:57 
[master 8224d99] http server
 1 file changed, 49 insertions(+)
 create mode 100644 cmd/nlpd/nlpd.go
╭─miki@saitama  nlp (git:master) 
╰─$ git push                                                                                        Sun Apr 28, 16:58 Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (5/5), 825 bytes | 825.00 KiB/s, done.
Total 5 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:tebeka/nlp.git
   36ab637..8224d99  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                               Sun Apr 28, 17:07 
^Csignal: interrupt╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                            Sun Apr 28, 17:07 1 ↵
2019/04/28 17:08:12 nlpd ready on :8080
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ NLPD_PORT=9090 go run ./cmd/nlpd                                                             Sun Apr 28, 17:08 1 ↵
2019/04/28 17:08:22 nlpd ready on :9090
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                            Sun Apr 28, 17:09 1 ↵
2019/04/28 17:20:41 nlpd ready on :8080
^Csignal: interrupt╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                            Sun Apr 28, 17:24 1 ↵
2019/04/28 17:24:13 nlpd ready on :8080
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go build ./cmd/nlpd                                                                          Sun Apr 28, 17:30 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ ls                                                                                              Sun Apr 28, 17:30 
cmd  example_test.go  go.mod  go.sum  nlpd  nlp.go  nlp.test  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ rm nlp.test                                                                                     Sun Apr 28, 17:30 
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd                                                                                     Sun Apr 28, 17:30 
-rwxr-xr-x 1 miki miki 9.1M Apr 28 17:30 nlpd
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd                                                                                       Sun Apr 28, 17:30 
nlpd: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, Go BuildID=SL5nkUmbQavyPqGcwShV/b3X6jR9y6QnRA5BUPRVJ/DWyA9vhWmshE80UK-Feg/p_0NKcG68oIifQS5ii9O, not stripped
╭─miki@saitama  nlp (git:master) 
╰─$ ldd nlpd                                                                                        Sun Apr 28, 17:31 
	linux-vdso.so.1 (0x00007ffe2c95e000)
	libpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007ff687896000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007ff6876d2000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff6878f4000)
╭─miki@saitama  nlp (git:master) 
╰─$CGO_ENABLED=0 go build ./cmd/nlpd                                                               Sun Apr 28, 17:32 
╭─miki@saitama  nlp (git:master) 
╰─$ ldd nlpd                                                                                        Sun Apr 28, 17:32 
	not a dynamic executable
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd                                                                                  Sun Apr 28, 17:32 1 ↵
-rwxr-xr-x 1 miki miki 9.0M Apr 28 17:32 nlpd
╭─miki@saitama  nlp (git:master) 
╰─$ go env GOOS                                                                                     Sun Apr 28, 17:32 
linux
╭─miki@saitama  nlp (git:master) 
╰─$ go env GOARCH                                                                                   Sun Apr 28, 17:36 
amd64
╭─miki@saitama  nlp (git:master) 
╰─$ GOOS=windows go build ./cmd/nlpd                                                                Sun Apr 28, 17:36 
╭─miki@saitama  nlp (git:master) 
╰─$ ls                                                                                              Sun Apr 28, 17:37 
cmd  example_test.go  go.mod  go.sum  nlpd  nlpd.exe  nlp.go  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd.exe                                                                                 Sun Apr 28, 17:37 
-rwxr-xr-x 1 miki miki 8.8M Apr 28 17:37 nlpd.exe
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd.exe                                                                                   Sun Apr 28, 17:37 
nlpd.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows
╭─miki@saitama  nlp (git:master) 
╰─$GOARCH=arm64 go build ./cmd/nlpd                                                                Sun Apr 28, 17:37 
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd                                                                                       Sun Apr 28, 17:38 
nlpd: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=50PsgenRk0SiW5yZjiWA/sPhR60k-YtlOIuutp4NR/-RCjV0Vu7_LVhsz69Tnj/dashtoAYXt9WdMr8TXEJ, not stripped
╭─miki@saitama  nlp (git:master) 
╰─$ docker images | grep alpine                                                                     Sun Apr 28, 17:38 
redis                                           alpine                                           a5cff96d7b8f        2 months ago        50.8MB
nginx                                           alpine                                           315798907716        4 months ago        17.8MB
quay.io/nuclio/handler-builder-golang-onbuild   0.7.4-amd64-alpine                               4b1ce3ecf9ff        4 months ago        420MB
python                                          3.6-alpine                                       1d981af1e3b4        5 months ago        74.3MB
alpine                                          3.7                                              34ea7509dcad        7 months ago        4.21MB
jenkins                                         alpine                                           2ad007d33253        17 months ago       223MB
╭─miki@saitama  nlp (git:master) 
╰─$ docker images | grep slim                                                                       Sun Apr 28, 17:42 
debian                                          stretch-slim                                     b805107aed7b        7 weeks ago         55.3MB
python                                          2.7-slim                                         f2ac6489d817        2 months ago        120MB
openjdk                                         11-jdk-slim                                      19f6e2b71c55        4 months ago        526MB
openjdk                                         8-jdk-slim                                       a1c07a12a70e        5 months ago        244MB
python                                          3.6-slim                                         ea57895cf3f9        5 months ago        138MB
python                                          3.7-slim                                         eda33421b45b        5 months ago        143MB
debian                                          jessie-slim                                      c75757d0c875        5 months ago        79.2MB
debian                                          9.5-slim                                         4b4471f624dc        6 months ago        55.3MB╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .                                                         Sun Apr 28, 17:42 
Sending build context to Docker daemon  18.39MB
Error response from daemon: Dockerfile parse error line 3: unknown instruction: WORK
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .                                                      Sun Apr 28, 17:44 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Running in 326e95b8963d
Removing intermediate container 326e95b8963d
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> 3df3213f8362
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in 0b1d629437b4
Removing intermediate container 0b1d629437b4
 ---> 91d1eb959268
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in cd2e7bbc9128
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container cd2e7bbc9128
 ---> 2dde5291659b
Step 6/9 : FROM debian:sterch-slim
manifest for debian:sterch-slim not found
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .                                                      Sun Apr 28, 17:45 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> 778c47395fe0
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in 252809506fee
Removing intermediate container 252809506fee
 ---> 95fc969b0432
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in 9ee993077043
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container 9ee993077043
 ---> 1a4c855e3632
Step 6/9 : FROM debian:stertch-slim
manifest for debian:stertch-slim not found
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .                                                      Sun Apr 28, 17:45 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> ec6b82e09ef2
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in a131fe5a2f7d
Removing intermediate container a131fe5a2f7d
 ---> 29571e83c114
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in 18ae75692191
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container 18ae75692191
 ---> 6c128c29e7fb
Step 6/9 : FROM debian:stretch-slim
 ---> b805107aed7b
Step 7/9 : COPY --from=build /nlp/nlpd /usr/local/bin
 ---> fc739d250668
Step 8/9 : ENV NLPD_PORT 8080
 ---> Running in 036f3cc9c5e7
Removing intermediate container 036f3cc9c5e7
 ---> 29d8127dadca
Step 9/9 : CMD nlpd
 ---> Running in 7126cccf153a
Removing intermediate container 7126cccf153a
 ---> 8531e54a0824
Successfully built 8531e54a0824
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile -t tebeka/nlpd .                                          Sun Apr 28, 17:46 
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> Using cache
 ---> ec6b82e09ef2
Step 4/9 : ENV CGO_ENABLED=0
 ---> Using cache
 ---> 29571e83c114
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Using cache
 ---> 6c128c29e7fb
Step 6/9 : FROM debian:stretch-slim
 ---> b805107aed7b
Step 7/9 : COPY --from=build /nlp/nlpd /usr/local/bin
 ---> Using cache ---> fc739d250668
Step 8/9 : ENV NLPD_PORT 8080
 ---> Using cache
 ---> 29d8127dadca
Step 9/9 : CMD nlpd
 ---> Using cache
 ---> 8531e54a0824
Successfully built 8531e54a0824
Successfully tagged tebeka/nlpd:latest
╭─miki@saitama  nlp (git:master) 
╰─$ docker run -p8080:8080 tebeka/nlpd                                                              Sun Apr 28, 17:46 
2019/04/28 14:46:29 nlpd ready on :8080^C^C^C^C^C^C%                                                                                                          ╭─miki@saitama  nlp (git:master) 
╰─$ docker run -p8080:8080 tebeka/nlpd                                                         Sun Apr 28, 17:49 137 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd --version                                                                Sun Apr 28, 17:49 130 ↵
nlpd version 0.2.0
╭─miki@saitama  nlp (git:master) 
╰─$ go build -ldflags='-X main.Version=0.3.0' ./cmd/nlpd                                            Sun Apr 28, 17:49 
╭─miki@saitama  nlp (git:master) 
╰─$ ./nlpd --version                                                                                Sun Apr 28, 17:50 
nlpd version 0.3.0
╭─miki@saitama  nlp (git:master) 
╰─$ git rev-parse --short HEAD                                                                      Sun Apr 28, 17:50 
8224d99
╭─miki@saitama  nlp (git:master) 
╰─$ make test                                                                                       Sun Apr 28, 17:50 
go test -v ./...
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- FAIL: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- FAIL: TestTokenize/<empty> (0.00s)
        require.go:157: 
            	Error Trace:	nlp_test.go:28
            	Error:      	Not equal: 
            	            	expected: []string(nil)
            	            	actual  : []string{}
            	            	
            	            	Diff:
            	            	--- Expected
            	            	+++ Actual
            	            	@@ -1,2 +1,3 @@
            	            	-([]string) <nil>
            	            	+([]string) {
            	            	+}
            	            	 
            	Test:       	TestTokenize/<empty>
            	Messages:   	tokenize
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
FAIL
FAIL	github.com/tebeka/nlp	0.003s
?   	github.com/tebeka/nlp/cmd/nlpd	[no test files]
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	(cached)
make: *** [Makefile:5: test] Error 1╭─miki@saitama  nlp (git:master) 
╰─$ make test                                                                                    Sun Apr 28, 17:54 2 ↵
go test -v ./...
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
?   	github.com/tebeka/nlp/cmd/nlpd	[no test files]
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	(cached)╭─miki@saitama  nlp (git:master) 
╰─$ make                                                                                            Sun Apr 28, 17:55 
Makefile:2: *** please pick a target.  Stop.
╭─miki@saitama  nlp (git:master) 
╰─$ tree                                                                                         Sun Apr 28, 17:55 2 ↵
.
├── cmd
│   └── nlpd
│       ├── Dockerfile
│       └── nlpd.go
├── example_test.go
├── go.mod
├── go.sum
├── Makefile
├── nlpd
├── nlpd.exe
├── nlp.go
├── nlp_test.go
├── prof.out
├── REAMDE.md
└── stemmer
    ├── stemmer.go
    └── stemmer_test.go

3 directories, 14 files    disasm           Output assembly listings annotated with samples
    dot              Outputs a graph in DOT format
    eog              Visualize graph through eog
    evince           Visualize graph through evince
    gif              Outputs a graph image in GIF format
    gv               Visualize graph through gv
    kcachegrind      Visualize report in KCachegrind
    list             Output annotated source for functions matching regexp
    pdf              Outputs a graph in PDF format
    peek             Output callers/callees of functions matching regexp
    png              Outputs a graph image in PNG format
    proto            Outputs the profile in compressed protobuf format
    ps               Outputs a graph in PS format
    raw              Outputs a text representation of the raw profile
    svg              Outputs a graph in SVG format
    tags             Outputs all tags in the profile
    text             Outputs top entries in text form
    top              Outputs top entries in text form
    topproto         Outputs top entries in compressed protobuf format
    traces           Outputs all profile samples in text form
    tree             Outputs a text rendering of call graph
    web              Visualize graph through web browser
    weblist          Display annotated source in a web browser
    o/options        List options and their current values
    quit/exit/^D     Exit pprof

  Options:
    call_tree        Create a context-sensitive call tree
    compact_labels   Show minimal headers
    divide_by        Ratio to divide all samples before visualization
    drop_negative    Ignore negative differences
    edgefraction     Hide edges below <f>*total
    focus            Restricts to samples going through a node matching regexp
    hide             Skips nodes matching regexp
    ignore           Skips paths going through any nodes matching regexp
    mean             Average sample value over first value (count)
    nodecount        Max number of nodes to show
    nodefraction     Hide nodes below <f>*total
    noinlines        Ignore inlines.
    normalize        Scales profile based on the base profile.
    output           Output filename for file-based outputs
    prune_from       Drops any functions below the matched frame.
    relative_percentages Show percentages relative to focused subgraph
    sample_index     Sample value to report (0-based index or name)
    show             Only show nodes matching regexp
    show_from        Drops functions above the highest matched frame.
    source_path      Search path for source files
    tagfocus         Restricts to samples with tags in range or matched by regexp
    taghide          Skip tags matching this regexp
    tagignore        Discard samples with tags in range or matched by regexp
    tagshow          Only consider tags matching this regexp
    trim             Honor nodefraction/edgefraction/nodecount defaults
    trim_path        Path to trim from source paths before search
    unit             Measurement units to display

  Option groups (only set one per group):
    cumulative       
      cum              Sort entries based on cumulative weight
      flat             Sort entries based on own weight
    granularity      
      addresses        Aggregate at the address level.
      filefunctions    Aggregate at the function level.
      files            Aggregate at the file level.
      functions        Aggregate at the function level.
      lines            Aggregate at the source code line level.
  :   Clear focus/ignore/hide/tagfocus/tagignore

  type "help <cmd|option>" for more information
(pprof) weblist
command weblist requires an argument
(pprof) weblist nlp
open /tmp/go-build964677140/b001/nlp.test: no such file or directory
[20323:20341:0428/161103.340524:ERROR:browser_process_sub_thread.cc(217)] Waited 4 ms for network service
(pprof) top 20
Showing nodes accounting for 1430ms, 86.14% of 1660ms total
Showing top 20 nodes out of 88
      flat  flat%   sum%        cum   cum%
     260ms 15.66% 15.66%      700ms 42.17%  regexp.(*Regexp).tryBacktrack
     160ms  9.64% 25.30%      160ms  9.64%  regexp.(*bitState).shouldVisit
     110ms  6.63% 31.93%      140ms  8.43%  regexp.(*bitState).push
     100ms  6.02% 37.95%     1180ms 71.08%  regexp.(*Regexp).backtrack
     100ms  6.02% 43.98%      100ms  6.02%  regexp/syntax.(*Inst).MatchRunePos
      70ms  4.22% 48.19%      130ms  7.83%  regexp.(*Regexp).FindAllString.func1
      70ms  4.22% 52.41%     1390ms 83.73%  regexp.(*Regexp).allMatches
      70ms  4.22% 56.63%       70ms  4.22%  regexp.(*inputString).step
      70ms  4.22% 60.84%      190ms 11.45%  runtime.mallocgc
      70ms  4.22% 65.06%      100ms  6.02%  strings.HasSuffix
      50ms  3.01% 68.07%      260ms 15.66%  runtime.growslice
      50ms  3.01% 71.08%       50ms  3.01%  runtime.memmove
      40ms  2.41% 73.49%       40ms  2.41%  runtime.procPin
      40ms  2.41% 75.90%       60ms  3.61%  strings.ToLower
      30ms  1.81% 77.71%       30ms  1.81%  runtime.heapBitsSetType
      30ms  1.81% 79.52%       30ms  1.81%  runtime.memclrNoHeapPointers
      30ms  1.81% 81.33%       30ms  1.81%  runtime.nextFreeFast
      30ms  1.81% 83.13%      110ms  6.63%  sync.(*Pool).Put
      30ms  1.81% 84.94%      100ms  6.02%  sync.(*Pool).pin
      20ms  1.20% 86.14%       20ms  1.20%  memeqbody
(pprof) q
Unrecognized command: "q"
(pprof) quit
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                                     Sun Apr 28, 16:12 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      5059 ns/op
PASS
ok  	github.com/tebeka/nlp	1.578s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                 Sun Apr 28, 16:12 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      4938 ns/op
PASS
ok  	github.com/tebeka/nlp	1.539s
╭─miki@saitama  nlp (git:master) 
╰─$ go test -v -bench . -run '^$'                 Sun Apr 28, 16:13 
goos: linux
goarch: amd64
pkg: github.com/tebeka/nlp
BenchmarkTokenize-4   	  300000	      4808 ns/op
PASS
ok  	github.com/tebeka/nlp	1.499s
╭─miki@saitama  nlp (git:master) 
╰─$ echo Back 4:30                Sun Apr 28, 16:13 
Back 4:30
╭─miki@saitama  nlp (git:master) 
╰─$ git status -u                Sun Apr 28, 16:18 
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   nlp.go
	modified:   nlp_test.go

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	nlp.test
	prof.out

no changes added to commit (use "git add" and/or "git commit -a")
╭─miki@saitama  nlp (git:master) 
╰─$ git add nlp.go nlp_test.go                 Sun Apr 28, 16:19 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'small speed optimization'                Sun Apr 28, 16:19 
[master 8484a7f] small speed optimization
 2 files changed, 16 insertions(+), 1 deletion(-)
╭─miki@saitama  nlp (git:master) 
╰─$ cat > .gitignore                Sun Apr 28, 16:19 
nlp.test
prof.out
╭─miki@saitama  nlp (git:master) 
╰─$ git add .gitignore                 Sun Apr 28, 16:19 
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'ignore'                Sun Apr 28, 16:19 
[master 36ab637] ignore
 1 file changed, 2 insertions(+)
 create mode 100644 .gitignore
╭─miki@saitama  nlp (git:master) 
╰─$ git push                Sun Apr 28, 16:19 
Enumerating objects: 10, done.
Counting objects: 100% (10/10), done.
Delta compression using up to 4 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (7/7), 965 bytes | 482.00 KiB/s, done.
Total 7 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 2 local objects.
To github.com:tebeka/nlp.git
   51a140e..36ab637  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir cmd/nlpd                 Sun Apr 28, 16:19 
mkdir: cannot create directory ‘cmd/nlpd’: No such file or directory
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir cmd/nlpd             Sun Apr 28, 16:36 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ ls            Sun Apr 28, 16:36 130 ↵
example_test.go  go.mod  go.sum  nlp.go  nlp.test  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ mkdir -p cmd/nlpd                Sun Apr 28, 16:36 
╭─miki@saitama  nlp (git:master) 
╰─$ tree                Sun Apr 28, 16:36 
.
├── cmd
│   └── nlpd
│       └── nlpd.go
├── example_test.go
├── go.mod
├── go.sum
├── nlp.go
├── nlp.test
├── nlp_test.go
├── prof.out
└── stemmer
    ├── stemmer.go
    └── stemmer_test.go

3 directories, 10 files
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                 Sun Apr 28, 16:36 
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ git add cmd/nlpd/nlpd.go              Sun Apr 28, 16:56 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ git commit -m 'http server'                Sun Apr 28, 16:57 
[master 8224d99] http server
 1 file changed, 49 insertions(+)
 create mode 100644 cmd/nlpd/nlpd.go
╭─miki@saitama  nlp (git:master) 
╰─$ git push                Sun Apr 28, 16:58 
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (5/5), 825 bytes | 825.00 KiB/s, done.
Total 5 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:tebeka/nlp.git
   36ab637..8224d99  master -> master
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                                                                 Sun Apr 28, 17:07 
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd             Sun Apr 28, 17:07 1 ↵
2019/04/28 17:08:12 nlpd ready on :8080
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ NLPD_PORT=9090 go run ./cmd/nlpd             Sun Apr 28, 17:08 1 ↵
2019/04/28 17:08:22 nlpd ready on :9090
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd                            Sun Apr 28, 17:09 1 ↵
2019/04/28 17:20:41 nlpd ready on :8080
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd             Sun Apr 28, 17:24 1 ↵
2019/04/28 17:24:13 nlpd ready on :8080
^Csignal: interrupt
╭─miki@saitama  nlp (git:master) 
╰─$ go build ./cmd/nlpd              Sun Apr 28, 17:30 1 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ ls                Sun Apr 28, 17:30 
cmd  example_test.go  go.mod  go.sum  nlpd  nlp.go  nlp.test  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ rm nlp.test                 Sun Apr 28, 17:30 
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd                 Sun Apr 28, 17:30 
-rwxr-xr-x 1 miki miki 9.1M Apr 28 17:30 nlpd
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd                 Sun Apr 28, 17:30 
nlpd: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, Go BuildID=SL5nkUmbQavyPqGcwShV/b3X6jR9y6QnRA5BUPRVJ/DWyA9vhWmshE80UK-Feg/p_0NKcG68oIifQS5ii9O, not stripped
╭─miki@saitama  nlp (git:master) 
╰─$ ldd nlpd                 Sun Apr 28, 17:31 
	linux-vdso.so.1 (0x00007ffe2c95e000)
	libpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007ff687896000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007ff6876d2000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff6878f4000)
╭─miki@saitama  nlp (git:master) 
╰─$ CGO_ENABLED=0 go build ./cmd/nlpd                Sun Apr 28, 17:32 
╭─miki@saitama  nlp (git:master) 
╰─$ ldd nlpd                                         Sun Apr 28, 17:32 
	not a dynamic executable
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd             Sun Apr 28, 17:32 1 ↵
-rwxr-xr-x 1 miki miki 9.0M Apr 28 17:32 nlpd
╭─miki@saitama  nlp (git:master) 
╰─$ go env GOOS                Sun Apr 28, 17:32 
linux
╭─miki@saitama  nlp (git:master) 
╰─$ go env GOARCH                Sun Apr 28, 17:36 
amd64
╭─miki@saitama  nlp (git:master) 
╰─$ GOOS=windows go build ./cmd/nlpd                 Sun Apr 28, 17:36 
╭─miki@saitama  nlp (git:master) 
╰─$ ls                Sun Apr 28, 17:37 
cmd  example_test.go  go.mod  go.sum  nlpd  nlpd.exe  nlp.go  nlp_test.go  prof.out  stemmer
╭─miki@saitama  nlp (git:master) 
╰─$ ls -lh nlpd.exe                 Sun Apr 28, 17:37 
-rwxr-xr-x 1 miki miki 8.8M Apr 28 17:37 nlpd.exe
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd.exe                Sun Apr 28, 17:37 
nlpd.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows
╭─miki@saitama  nlp (git:master) 
╰─$ GOARCH=arm64 go build ./cmd/nlpd                Sun Apr 28, 17:37 
╭─miki@saitama  nlp (git:master) 
╰─$ file nlpd                Sun Apr 28, 17:38 
nlpd: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=50PsgenRk0SiW5yZjiWA/sPhR60k-YtlOIuutp4NR/-RCjV0Vu7_LVhsz69Tnj/dashtoAYXt9WdMr8TXEJ, not stripped
╭─miki@saitama  nlp (git:master) 
╰─$ docker images | grep alpine                Sun Apr 28, 17:38 
redis                                           alpine                                           a5cff96d7b8f        2 months ago        50.8MB
nginx                                           alpine                                           315798907716        4 months ago        17.8MB
quay.io/nuclio/handler-builder-golang-onbuild   0.7.4-amd64-alpine                               4b1ce3ecf9ff        4 months ago        420MB
python                                          3.6-alpine                                       1d981af1e3b4        5 months ago        74.3MB
alpine                                          3.7                                              34ea7509dcad        7 months ago        4.21MB
jenkins                                         alpine                                           2ad007d33253        17 months ago       223MB
╭─miki@saitama  nlp (git:master) 
╰─$ docker images | grep slim                Sun Apr 28, 17:42 
debian                                          stretch-slim                                     b805107aed7b        7 weeks ago         55.3MB
python                                          2.7-slim                                         f2ac6489d817        2 months ago        120MB
openjdk                                         11-jdk-slim                                      19f6e2b71c55        4 months ago        526MB
openjdk                                         8-jdk-slim                                       a1c07a12a70e        5 months ago        244MB
python                                          3.6-slim                                         ea57895cf3f9        5 months ago        138MB
python                                          3.7-slim                                         eda33421b45b        5 months ago        143MB
debian                                          jessie-slim                                      c75757d0c875        5 months ago        79.2MB
debian                                          9.5-slim                                         4b4471f624dc        6 months ago        55.3MB
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .                Sun Apr 28, 17:42 
Sending build context to Docker daemon  18.39MB
Error response from daemon: Dockerfile parse error line 3: unknown instruction: WORK
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .             Sun Apr 28, 17:44 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Running in 326e95b8963d
Removing intermediate container 326e95b8963d
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> 3df3213f8362
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in 0b1d629437b4
Removing intermediate container 0b1d629437b4
 ---> 91d1eb959268
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in cd2e7bbc9128
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0
go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container cd2e7bbc9128
 ---> 2dde5291659b
Step 6/9 : FROM debian:sterch-slim
manifest for debian:sterch-slim not found
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .             Sun Apr 28, 17:45 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> 778c47395fe0
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in 252809506fee
Removing intermediate container 252809506fee
 ---> 95fc969b0432
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in 9ee993077043
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0
go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container 9ee993077043
 ---> 1a4c855e3632
Step 6/9 : FROM debian:stertch-slim
manifest for debian:stertch-slim not found
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile .             Sun Apr 28, 17:45 1 ↵
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> ec6b82e09ef2
Step 4/9 : ENV CGO_ENABLED=0
 ---> Running in a131fe5a2f7d
Removing intermediate container a131fe5a2f7d
 ---> 29571e83c114
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Running in 18ae75692191
go: finding github.com/stretchr/testify v1.3.0
go: finding github.com/kelseyhightower/envconfig v1.3.0
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/objx v0.1.0
go: finding github.com/davecgh/go-spew v1.1.0
go: downloading github.com/kelseyhightower/envconfig v1.3.0
go: extracting github.com/kelseyhightower/envconfig v1.3.0
Removing intermediate container 18ae75692191
 ---> 6c128c29e7fb
Step 6/9 : FROM debian:stretch-slim
 ---> b805107aed7b
Step 7/9 : COPY --from=build /nlp/nlpd /usr/local/bin
 ---> fc739d250668
Step 8/9 : ENV NLPD_PORT 8080
 ---> Running in 036f3cc9c5e7
Removing intermediate container 036f3cc9c5e7
 ---> 29d8127dadca
Step 9/9 : CMD nlpd
 ---> Running in 7126cccf153a
Removing intermediate container 7126cccf153a
 ---> 8531e54a0824
Successfully built 8531e54a0824
╭─miki@saitama  nlp (git:master) 
╰─$ docker build -f ./cmd/nlpd/Dockerfile -t tebeka/nlpd .                Sun Apr 28, 17:46 
Sending build context to Docker daemon  18.39MB
Step 1/9 : FROM golang:1.12.4 as build
 ---> b860ab44e93e
Step 2/9 : WORKDIR /nlp
 ---> Using cache
 ---> c3ecc07afa17
Step 3/9 : COPY . .
 ---> Using cache
 ---> ec6b82e09ef2
Step 4/9 : ENV CGO_ENABLED=0
 ---> Using cache
 ---> 29571e83c114
Step 5/9 : RUN go build ./cmd/nlpd
 ---> Using cache
 ---> 6c128c29e7fb
Step 6/9 : FROM debian:stretch-slim
 ---> b805107aed7b
Step 7/9 : COPY --from=build /nlp/nlpd /usr/local/bin
 ---> Using cache
 ---> fc739d250668
Step 8/9 : ENV NLPD_PORT 8080
 ---> Using cache
 ---> 29d8127dadca
Step 9/9 : CMD nlpd
 ---> Using cache
 ---> 8531e54a0824
Successfully built 8531e54a0824
Successfully tagged tebeka/nlpd:latest
╭─miki@saitama  nlp (git:master) 
╰─$ docker run -p8080:8080 tebeka/nlpd                Sun Apr 28, 17:46 
2019/04/28 14:46:29 nlpd ready on :8080
^C^C^C^C^C^C%                                                                                                          ╭─miki@saitama  nlp (git:master) 
╰─$ docker run -p8080:8080 tebeka/nlpd           Sun Apr 28, 17:49 137 ↵
╭─miki@saitama  nlp (git:master) 
╰─$ go run ./cmd/nlpd --version           Sun Apr 28, 17:49 130 ↵
nlpd version 0.2.0
╭─miki@saitama  nlp (git:master) 
╰─$ go build -ldflags='-X main.Version=0.3.0' ./cmd/nlpd                 Sun Apr 28, 17:49 
╭─miki@saitama  nlp (git:master) 
╰─$ ./nlpd --version                Sun Apr 28, 17:50 
nlpd version 0.3.0
╭─miki@saitama  nlp (git:master) 
╰─$ git rev-parse --short HEAD                Sun Apr 28, 17:50 
8224d99
╭─miki@saitama  nlp (git:master) 
╰─$ make test                Sun Apr 28, 17:50 
go test -v ./...
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- FAIL: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- FAIL: TestTokenize/<empty> (0.00s)
        require.go:157: 
            	Error Trace:	nlp_test.go:28
            	Error:      	Not equal: 
            	            	expected: []string(nil)
            	            	actual  : []string{}
            	            	
            	            	Diff:
            	            	--- Expected
            	            	+++ Actual
            	            	@@ -1,2 +1,3 @@
            	            	-([]string) <nil>
            	            	+([]string) {
            	            	+}
            	            	 
            	Test:       	TestTokenize/<empty>
            	Messages:   	tokenize
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
FAIL
FAIL	github.com/tebeka/nlp	0.003s
?   	github.com/tebeka/nlp/cmd/nlpd	[no test files]
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	(cached)
make: *** [Makefile:5: test] Error 1
╭─miki@saitama  nlp (git:master) 
╰─$ make test             Sun Apr 28, 17:54 2 ↵
go test -v ./...
=== RUN   TestTokenize
=== RUN   TestTokenize/Who's_on_first?
=== RUN   TestTokenize/<empty>
--- PASS: TestTokenize (0.00s)
    --- PASS: TestTokenize/Who's_on_first? (0.00s)
    --- PASS: TestTokenize/<empty> (0.00s)
=== RUN   TestQuick
--- PASS: TestQuick (0.00s)
=== RUN   ExampleTokenize
--- PASS: ExampleTokenize (0.00s)
PASS
ok  	github.com/tebeka/nlp	0.002s
?   	github.com/tebeka/nlp/cmd/nlpd	[no test files]
=== RUN   TestStem
=== RUN   TestStem/runs
=== RUN   TestStem/sleeping
=== RUN   TestStem/fish
=== RUN   TestStem/#00
--- PASS: TestStem (0.00s)
    --- PASS: TestStem/runs (0.00s)
    --- PASS: TestStem/sleeping (0.00s)
    --- PASS: TestStem/fish (0.00s)
    --- PASS: TestStem/#00 (0.00s)
PASS
ok  	github.com/tebeka/nlp/stemmer	(cached)
╭─miki@saitama  nlp (git:master) 
╰─$ make                Sun Apr 28, 17:55 
Makefile:2: *** please pick a target.  Stop.
╭─miki@saitama  nlp (git:master) 
╰─$ tree             Sun Apr 28, 17:55 2 ↵
.
├── cmd
│   └── nlpd
│       ├── Dockerfile
│       └── nlpd.go
├── example_test.go
├── go.mod
├── go.sum
├── Makefile
├── nlpd
├── nlpd.exe
├── nlp.go
├── nlp_test.go
├── prof.out
├── REAMDE.md
└── stemmer
    ├── stemmer.go
    └── stemmer_test.go

3 directories, 14 files
╭─miki@saitama  nlp (git:master) 
╰─$ rm prof.out nlpd*                Sun Apr 28, 17:56 
╭─miki@saitama  nlp (git:master) 
╰─$ tree                Sun Apr 28, 17:56 
.
├── cmd
│   └── nlpd
│       ├── Dockerfile
│       └── nlpd.go
├── example_test.go
├── go.mod
├── go.sum
├── Makefile
├── nlp.go
├── nlp_test.go
├── REAMDE.md
└── stemmer
    ├── stemmer.go
    └── stemmer_test.go

3 directories, 11 files
╭─miki@saitama  nlp (git:master) 
╰─$